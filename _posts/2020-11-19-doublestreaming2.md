---
layout: post
title:  "double streaming 2"
date:   "2020-11-19 10:00:00"
---


上期我们聊了双流的问题，接下来借着一个实际案例来看看。

有两条信息流，一条是Tesla股票的K线行情变化，一条是用户设置的条件单记录。

那么要如何设计一个流处理装置，来保证恰好一次计算呢？


## 行情信息流

该流具备驱动流的特征，有单调性和持续性。因为一直有数据产生，所以不需要额外增加心跳数据包，

只需要增加一个单调性的filter就可以了（当前数据的时间或者序号需要大于前一条）。当行情数据

到达时会写入内存缓存中，该缓存会保持一段时间，后面会介绍它的用途。最后通过行情数据本身的

时间戳来控制条件单记录的加载的时机。


## 条件单信息流

该流的数据量比较小，而且可能局部乱序，为此增加了心跳数据包，代表时间进度。心跳数据包只包

含一个时间戳，其含义是该信息流中不会再出现比此时间戳更早的数据了，在生成心跳包的时候我们

可以刻意的delay几秒。这个和flink中的watermarket很相似。心跳包的数据到达时，可以触发过

期行情缓存数据的清理工作。因为这些行情信息再也用不到了。条件单的数据到达时，如果早于行情

当前的时间进度，那么就放在cache里，等待行情数据到达时触发其加载。如果晚于行情的当前的时

间进度的话，就要触发一个特殊环节，利用行情缓存的历史数据进行计算，之后合并结果。


## 总结

上面两条流的处理方式就是前一篇Blog中提到的协调器，满足如下四个功能：

驱动流缓存池、被动流缓存池、被动流增量加载方法、被流动回溯方法。

具体代码可以在fevernova的markettracing中找到，这里就不多说了。