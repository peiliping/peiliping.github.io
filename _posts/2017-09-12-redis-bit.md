---
layout: post
title:  "Redis中的Bitmap数据结构"
date:   "2017-09-01 09:00:00"
categories: "redis lua bitmap"
permalink: /archivers/2017-09-12-redis-bit
---

Redis最早被大家熟知，是因为其高效的读写速率和丰富的数据结构。

近两年在实时计算方面的应用也非常多，尤其是与bit有关的操作。

## Redis中常见的Bit操作

1、SetBit
2、GetBit
3、BitOp
4、BitPos
5、BitField

## 计算日活跃用户

计算日活是一个非常古老的话题，也是面试题目中很常见的一个问题。

其变种问题有：有限内存的数据排序，在线用户统计等等。

在网上有很多文章介绍如何利用Redis做高效的日活统计，请自行阅读。

使用bitmap来作为数据的存储好处就是高效、节省内存。

## 维度分析的需求

单一的日活跃统计已经不能满足需求了，在实际工作中，运营人员希望能够实现

一些更为复杂的统计分析，比如漏斗模型、多维度组合分析等等。有很多公司

已经积累了大量的用户特征数据，开始完善用户画像，通过用户的特征来优化

业务，提高商业价值。简单概括，我们需要一个列式的存储，方便增加新列，

需要类似bitmap的索引能够高效完成多个维度的快速筛选。

近几年以BitMap索引著称的Druid，是一个非常好的选择，在维度统计方面

性能优异，缺点就是架构比较复杂，维护成本比较高。另外还有ES、Kylin等。

也有人用Hyperloglog之类的数据结构做日活统计，但不能解决多维度的问题。

## Redis + Lua

Redis提供了Bit，但不足以完成多维分析的操作，于是引入LuaScript。

使用过Redis的人都知道通过批量提交可以提升效率，如果我们的需求是先Get

在Put，那么这个原子性就很难保证。LuaScript可以把这种业务逻辑封装好，

在Redis服务器上执行，因为Redis本身的单线程特性，不用再处理并发问题了。

如果我们的计算逻辑包含迭代，那么让Lua在Redis内部完成效率会更高。

## 如何构建BitmMap索引

每个维度的每一个值都要单独构建一个BitMap，所以需要维护一个Value的列表。

之前在看Kylin的时候，有用一个TrieTree的结构维护Value字典信息。

Sybase之前有一个专利叫BitWise，结合TrieTree，可以方便实现Between逻辑。

维度值的膨胀是一个需要高度关注的问题，如果控制不好会吃掉非常多的存储空间。

假如我们有一亿个用户ID，Bitmap就非常大，因为数据不连续，非常浪费内存。

所以我们要对数据做一下分块的操作，比如每16384个连续用户ID为一个Block。

Block的大小会影响存储的开销，如果分的太小，会导致查询性能下降。

因为数据分了Block，所以还需要维护一个Block的列表。这个地方和之前在

扩展Roaringbitmap的时候是一样，通过位移运算来计算offset。

如果没有什么附加信息的话，我们仍然可以用Bitmap来维护这个列表。

## 如何查询

BitMap的操作类型就是逻辑运算(与、或、非)，那么根据选取的维度列序号和

维度值找到Bitmap，再对BitMap进行逻辑运算，结果保存在一个临时的Key中，

最后对其求bitcount，释放内存。

遍历Block列表的时候，我用到了BitPos，这个操作的参数非常麻烦，

参数是byte级别的，返回值是bit，需要自己加逻辑去控制一下。

## demo code

在Redis里执行的脚本，负责写入数据和查询数据

```
local resty_redis = require "resty.redis"
local redis       = resty_redis:new()
redis:set_timeout(1000)
local ok , err    = redis:connect("127.0.0.1", 6379)

if err then
  ngx.say(err)
  return
end

local scripts = ngx.shared.scripts

local shaw = redis:script("LOAD" , 
[[
  local tableName , dateTime , uidNumber = KEYS[1] , KEYS[2] , tonumber(KEYS[3])
  
  local blockSeq , lineSeq 
  if uidNumber >= 2147483648 then
  	blockSeq = math.modf(uidNumber / 16384)  
  	lineSeq  = uidNumber % 16384
  else
  	blockSeq , lineSeq = bit.rshift(uidNumber , 14) , bit.band(uidNumber , 16383)
  end
  
  local keyT4N = {"T-" , tableName , "-" , dateTime , "-Nest"}
  local keyT4V = {"T-" , tableName , "-" , dateTime , "-" , 6 , "-" , "VS"}
  local keyT4M = {"T-" , tableName , "-" , dateTime , "-" , 6 , "-" , 8 , "-BMP-" , blockSeq}

  for index , val in ipairs(ARGV) do
    keyT4V[6] , keyT4M[6] = index , index
    local key4V = table.concat(keyT4V)
    local m = redis.call("SISMEMBER" , key4V , val)
    if m == 1 then
      keyT4M[8] = val
      local key4M = table.concat(keyT4M)
      redis.call("setbit" , key4M , lineSeq , 1)  
    else
      local totalNum = redis.call("SCARD" , key4V)
      
      if totalNum >= 1024 then
        val = "IGNORE"
      end
      if totalNum <= 1024 then 
        redis.call("SADD" , key4V , val)
      end
      
      if totalNum == 0 then
        redis.call("expire" , key4V , 86400 * 7)    
      end

      keyT4M[8] = val
      local key4M = table.concat(keyT4M)
      redis.call("setbit" , key4M , lineSeq , 1)
      redis.call("expire" , key4M , 86400 * 7)
    end
  end
  local key4N = table.concat(keyT4N)
  redis.call("setbit" , key4N , blockSeq , 1)
  return true
]]
)

scripts:set("WriteScript", shaw)
ngx.say("WriteScript : " .. shaw)

local shar = redis:script("LOAD" , 
[[
  local result = 0
  local tableName , dateTime = KEYS[1] , KEYS[2]
  
  local keyT4N = {"T-" , tableName , "-" , dateTime , "-Nest"}
  local key4N = table.concat(keyT4N)

  local subKeys , subKeysT = {} , {}
  for index = 1 , #ARGV , 2 do
    table.insert(subKeysT , {"T-" , tableName , "-" , dateTime , "-" , ARGV[index] , "-" , ARGV[index+1] , "-BMP-" , 10})
  end

  local bytepos = 0
  local pos = redis.call("bitpos" , key4N , 1 , bytepos)
  while (pos >= 0)
  do
    for g = pos , pos + 7 - bit.band(pos , 7) do
      local fill = redis.call("getbit" , key4N , g)
      if fill == 1 then
        for index , val in ipairs(subKeysT) do
          val[10] = g
          subKeys[index] = table.concat(val)
        end
        redis.call("bitop" , "AND" , "_TMP_" , unpack(subKeys))
        local uv = redis.call("bitcount" , "_TMP_")
        result = result + uv
      end
    end

    bytepos = bit.rshift(pos , 3) + 1 
    pos = redis.call("bitpos" , key4N , 1 , bytepos)
  end
  redis.call("del" , "_TMP_")
  return result
]]
)

scripts:set("ReadScript", shar)
ngx.say("ReadScript : " .. shar)

redis:close()

```

Openresty+lua包装的查询接口

```
local ngx_re      = require "ngx.re"
local resty_redis = require "resty.redis"
local redis       = resty_redis:new()
redis:set_timeout(1000)
local ok , err    = redis:connect("127.0.0.1", 6379)

if err then
  ngx.say(err)
  return
end

local scripts = ngx.shared.scripts

local tableName = ngx.var.arg_table
local dateTime  = ngx.var.arg_datetime

local dimsStr   = ngx.var.arg_dims
local dims      = ngx_re.split(dimsStr , ",")

local r = redis:evalsha(scripts:get("ReadScript") , 2 , tableName , dateTime , unpack(dims))
ngx.say(r)
redis:close()
```
