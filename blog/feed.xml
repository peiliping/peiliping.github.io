<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pei LiPing's Blog</title>
    <description>Augur
</description>
    <link>http://peiliping.github.io/blog/</link>
    <atom:link href="http://peiliping.github.io/blog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 25 Jan 2022 15:24:43 +0800</pubDate>
    <lastBuildDate>Tue, 25 Jan 2022 15:24:43 +0800</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>Pine</title>
        <description>&lt;p&gt;最近看到Tradingview的Pine脚本，感觉很有意思，打算尝试一下。&lt;/p&gt;

&lt;h2 id=&quot;ma&quot;&gt;MA指标&lt;/h2&gt;

&lt;p&gt;TV上的指标都可以看到源代码，我们就从最简单的MA指标看看吧。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
indicator(title=&quot;Moving Average&quot;, shorttitle=&quot;MA&quot;, overlay=true, timeframe=&quot;&quot;, timeframe_gaps=true)
len = input.int(9, minval=1, title=&quot;Length&quot;)
src = input(close, title=&quot;Source&quot;)
offset = input.int(title=&quot;Offset&quot;, defval=0, minval=-500, maxval=500)
out = ta.sma(src, len)
plot(out, color=color.blue, title=&quot;MA&quot;, offset=offset)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;简单注释一下：&lt;/p&gt;

&lt;p&gt;input代表从图形化界面的设置中可以填写变更的，close指k线的收盘价。&lt;/p&gt;

&lt;p&gt;ta.sma就是MA指标的计算公式，plot函数我们就理解为渲染好了,plot有很多参数可调，&lt;/p&gt;

&lt;p&gt;比如控制线的粗细、颜色。&lt;/p&gt;

&lt;h2 id=&quot;mac&quot;&gt;照葫芦画瓢 MAC指标&lt;/h2&gt;

&lt;p&gt;第一次体验我们就不挑战难度了，弄一个MA指标的组合指标，一般使用MA的人都会用一个短周期的和一个长周期的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
indicator(title=&quot;Moving Average Couple&quot;, shorttitle=&quot;MAC&quot;, overlay=true, timeframe=&quot;&quot;, timeframe_gaps=true)

len1 = input.int(30, minval=1, title=&quot;Length&quot;)
len2 = input.int(59, minval=1, title=&quot;Length&quot;)

out1 = ta.sma(close, len1)
out2 = ta.sma(close, len2)

plot(out1, color=color.green, linewidth=2, title=&quot;MAC1&quot;, offset=0)
plot(out2, color=color.blue, linewidth=2, title=&quot;MAC2&quot;, offset=0)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;只是简单的加了一条线，然后控制了一下线的颜色和粗细。&lt;/p&gt;

&lt;p&gt;免费版TV限制了同时使用的Indicator数量，可以把多个指标的代码合并到一起，绕过限制吧。&lt;/p&gt;
</description>
        <pubDate>Sat, 20 Nov 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-11-20-Pine</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-11-20-Pine</guid>
        
        
        <category>Pine</category>
        
      </item>
    
      <item>
        <title>Baby</title>
        <description>&lt;p&gt;前几天我们家的宝宝出生了，真的是一波三折。&lt;/p&gt;

&lt;p&gt;希望小豌豆健康成长，本月停更，学习换尿布去了。&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Oct 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-10-10-baby</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-10-10-baby</guid>
        
        
        <category>baby</category>
        
        <category>birthday</category>
        
      </item>
    
      <item>
        <title>Wyckoff2</title>
        <description>&lt;p&gt;上一篇讲了点有关威科夫的量价理论，这里继续说一说。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;趋势与画辅助线&lt;/h2&gt;

&lt;p&gt;无论是何门何派，画辅助线都是必须的，但是辅助线经常是主观的。&lt;/p&gt;

&lt;p&gt;K线与辅助线交织在一起，经常无法做出决策。看历史怎么都对，实战中一卖就涨。&lt;/p&gt;

&lt;p&gt;如果等辅助线和K线的关系明确了，那么大部分利润也就没有了。&lt;/p&gt;

&lt;p&gt;威科夫理论中经常画横线作为支撑和压力线，这个方法我觉得还是比较可取的，&lt;/p&gt;

&lt;p&gt;但画横线不是单纯的基于价格和图形，也是要基于成交量的。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;关于成交量&lt;/h2&gt;

&lt;p&gt;在威科夫的理论中成交量是非常的关键，但是所有人都知道主力自己可以创造无效成交量。&lt;/p&gt;

&lt;p&gt;所以一个充分博弈的标的，他的成交量才失真最小，可靠性最大。&lt;/p&gt;

&lt;p&gt;至于什么主力动向数据、大单买入卖出，更是扯淡。&lt;/p&gt;

&lt;p&gt;去看看操盘软件里如何买卖就知道了，这种方法根本判断不出来。&lt;/p&gt;

&lt;p&gt;大单成交方向不一定代表主力方向，但是小单成交一定包含散户的趋势。&lt;/p&gt;

&lt;p&gt;如果大单连续主动买入时，只与深度中的大单成交而不与散单成交，基本上就是主力在自成交。&lt;/p&gt;

&lt;p&gt;大单如果想隐秘买入行为的话，一般是连下两单。第一单是LimitBuy，并且数量远超过深度中的量。&lt;/p&gt;

&lt;p&gt;此单成交后会把价格拉升到LimitBuy的目标价，并且买一位置有一个很大的买单。&lt;/p&gt;

&lt;p&gt;第二单为IOC Sell，价格与LimitBuy的价格相同。IOC的意思是立即成交，余下的取消。&lt;/p&gt;

&lt;p&gt;这样买一的大单就被吃掉了，如果Sell的Amout大于买一的Amount，成交后余下的会被自动取消。&lt;/p&gt;

&lt;p&gt;如果有人统计这一分钟里的大单的主动买入和卖出，会发现主动买入100个，主动卖出500个，&lt;/p&gt;

&lt;p&gt;统计结果为主动卖出400个。而实际情况是只主动买了100个。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;压力与支撑&lt;/h2&gt;

&lt;p&gt;通过成交量来判断支撑与压力，我觉得也不是很合理，当然绝大部分交易者只能用成交量来判断。&lt;/p&gt;

&lt;p&gt;压力与支撑本质上有两个数据组成，一个是盘口数据（也就是买卖盘深度），一个是成交明细。&lt;/p&gt;

&lt;p&gt;分别举个例子：&lt;/p&gt;

&lt;p&gt;1、如果有人在买一挂了一个无比巨大的买单，无形中就是一个支撑，愿意卖的人就少了。&lt;/p&gt;

&lt;p&gt;2、关注已成交订单中被成交的方向，当前1h下跌2%，看似十分凶猛，但是却不继续下跌了。&lt;/p&gt;

&lt;p&gt;有可能某些主力资金在这里连续的挂PostOnly单子悄悄的收货，利用恐慌的抛盘完成收货目的。&lt;/p&gt;

&lt;p&gt;这种把抛盘密集消化掉的行为才是最有效的支撑，但统计却都是主动卖出行为。&lt;/p&gt;

&lt;p&gt;大多数人对压力和支撑的判断基本上是意识流，我还是建议把他数值化，可以参考加权跳动量的计算方式。&lt;/p&gt;
</description>
        <pubDate>Sat, 11 Sep 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-09-11-wyckoff2</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-09-11-wyckoff2</guid>
        
        
        <category>wyckoff</category>
        
      </item>
    
      <item>
        <title>Wyckoff</title>
        <description>&lt;p&gt;最近在和一个做二级市场投资的朋友聊天时，听说了威科夫的量价理论。&lt;/p&gt;

&lt;p&gt;在了解了大致的思想之后，我觉得当中的量价关系十分有趣，花了一些时间探索了一下。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;量价理论&lt;/h2&gt;

&lt;p&gt;K线图有两个核心元素：价格（开高低收）和成交量，价格的趋势和成交量的情况相互验证。&lt;/p&gt;

&lt;p&gt;量价理论并不是一个指标，而是一种对抗的思维。市场中存在少数派盈利的主力和盲从的韭菜，&lt;/p&gt;

&lt;p&gt;在一个大的涨跌周期中，反复对抗博弈，量与价就在表达这个对抗博弈的过程。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;关于指标&lt;/h2&gt;

&lt;p&gt;市面上绝大多数交易策略都是以XX指标组合为基础，比如均线、MACD、KDJ等。&lt;/p&gt;

&lt;p&gt;我之前也写过两期关于ta4j的blog，还实现了一个指标基础函数库。&lt;/p&gt;

&lt;p&gt;对比量价理论后，我把基于指标的策略称为静态策略，就好像诸葛亮给的三个锦囊。&lt;/p&gt;

&lt;p&gt;这种神话故事根本就不具备实操性，你可能会觉得在某个时期这个策略能挣钱，但长期一定无法盈利。&lt;/p&gt;

&lt;p&gt;有的人做了大量的回测来提高他策略的有效性，我觉得通过回测来调整参数，可以直接定义为过拟合。&lt;/p&gt;

&lt;p&gt;其实绝大多数指标和图形理论都和量价有联系，比如头肩图形、波浪理论等等。&lt;/p&gt;

&lt;p&gt;将复杂的对抗归纳成一些可被识别的图形，方便教学传播、办班收费。&lt;/p&gt;

&lt;p&gt;而且指标基本上都只用价格信息，不用成交量，因为成交量随机性太强，很难被指标化。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;充分博弈市场&lt;/h2&gt;

&lt;p&gt;如果你想践行量价理论，我个人觉得一定要找一个充分博弈的标的。&lt;/p&gt;

&lt;p&gt;成交量巨大、参与人数众多、还有很多自以为是的量化策略在跑。&lt;/p&gt;

&lt;p&gt;在这种标的下，专业机构盈利是需要极其复杂的操盘手法的，趋势惯性和量价博弈也才有意义。&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Aug 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-08-19-wyckoff</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-08-19-wyckoff</guid>
        
        
        <category>wyckoff</category>
        
      </item>
    
      <item>
        <title>write file</title>
        <description>&lt;p&gt;最近在优化一些shell脚本任务，涉及到对文件的读写过程，这里聊聊我碰到的一些问题。&lt;/p&gt;

&lt;p&gt;我的脚本主要是对数据进行统计和计算，数据具有时序性，每分钟会有一行结果存在结果文件中。&lt;/p&gt;

&lt;p&gt;脚本每分钟执行一次，每次计算上一分钟和当前分钟的结果。保存结果数据时，会涉及到删除结果文件的最后一行，因为最后一分钟会被修正。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;如何衔接两次任务的时间&lt;/h2&gt;

&lt;p&gt;数据结果的文件每一行都对应一分钟的数据，每行开头都记录对应的时间戳。&lt;/p&gt;

&lt;p&gt;每次任务开始时，都读取结果文件的末尾，计算合理的数据时间。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
thishourday=`date &quot;+%Y-%m-%d&quot;`
startTime=`date -d &quot;${thishourday}&quot; +%s`

if [ -f &quot;$rfile&quot; ]; then
  startTime=`tail -n 1 $rfile | awk '{print $1}'`
else
  touch $rfile
fi

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;dailyrolling&quot;&gt;原始数据文件有DailyRolling&lt;/h2&gt;

&lt;p&gt;这就意味着每天00:00处理数据时，需要读取前一天的文件和当天文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
starthourday=`date --date=@${startTime} &quot;+%Y-%m-%d&quot;`

if [ $starthourday = $thishourday  ];then
  dfile=$dfile
else
  dfile=$dfile&quot;-&quot;$starthourday&quot; &quot;$dfile
fi

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;保存计算结果&lt;/h2&gt;

&lt;p&gt;每次计算任务完成后，都先将数据写入临时文件tfile中，接下来我们删除结果文件的最后一行。&lt;/p&gt;

&lt;p&gt;删除我们用了一个简单的命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
sed -i '$ d' $rfile

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后我们将临时文件Merge到结果文件的末尾，删除临时文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
cat $tfile &amp;gt;&amp;gt; $rfile
rm -rf $tfile

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;性能问题&lt;/h2&gt;

&lt;p&gt;如果结果文件越来越大，这个任务会越来越慢，主要的性能问题在删除文件最后一行这一步。&lt;/p&gt;

&lt;p&gt;sed删除最后一行这样的方式，几乎等于把整个文件重写了一遍。有兴趣的朋友可以看看这篇&lt;a href=&quot;https://www.codenong.com/4881930/&quot;&gt;Blog&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我觉得出现这个问题本身就代表了设计问题，临时数据（最后一行）是否要直接写入结果文件？&lt;/p&gt;

&lt;p&gt;可以借鉴Compaction那样的思路，将不确定的临时数据写入临时文件，当可以确定时写入正式的结果文件中,规避性能问题。&lt;/p&gt;

&lt;p&gt;最好还是把这些数据存入数据库吧，时序数据库千千万。&lt;/p&gt;
</description>
        <pubDate>Wed, 28 Jul 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-07-28-writefile</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-07-28-writefile</guid>
        
        
        <category>shell</category>
        
        <category>file</category>
        
      </item>
    
      <item>
        <title>flock</title>
        <description>&lt;p&gt;最近购买了一台腾讯云的服务器跑一些小程序，在整理crontab时发现了一个腾讯云的定时任务，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*/5 * * * * flock -xn /tmp/stargate.lock -c '/usr/local/qcloud/stargate/admin/start.sh &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;脚本是为了保证腾讯云agent存活的，这个不是我们关注的重点，重点是flock这个命令。&lt;/p&gt;

&lt;p&gt;虽然经常与服务器打交道，但是flock这个命令还是比较陌生的。&lt;/p&gt;

&lt;h2 id=&quot;flock&quot;&gt;flock&lt;/h2&gt;

&lt;p&gt;以下内容摘抄自cnblogs。&lt;/p&gt;

&lt;p&gt;如果两个进程同时启动了某个脚本，那么很容易导致数据的混乱，这个时候需要锁来协调解决。&lt;/p&gt;

&lt;p&gt;flock是建议性锁，不具备强制性。一个进程使用flock将文件锁住，另一个进程也可以直接操作正在被锁的文件，修改文件中的数据。&lt;/p&gt;

&lt;p&gt;flock只是用于检测文件是否被加锁，针对文件已经被加锁，另一个进程写入数据的情况，内核不会阻止这个进程的写入操作。&lt;/p&gt;

&lt;p&gt;flock主要三种操作类型：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LOCK_SH，共享锁，多个进程可以使用同一把锁，常被用作读共享锁；
LOCK_EX，排他锁，同时只允许一个进程使用，常被用作写锁；
LOCK_UN，释放锁；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section&quot;&gt;参数&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-s,--shared：获取一个共享锁，在定向为某文件的FD上设置共享锁而未释放锁的时间内，其他进程试图在定向为此文件的FD上设置独占锁的请求失败，而其他进程试图在定向为此文件的FD上设置共享锁的请求会成功。
-x，-e，--exclusive：获取一个排它锁，或者称为写入锁，为默认项
-u，--unlock：手动释放锁，一般情况不必须，当FD关闭时，系统会自动解锁，此参数用于脚本命令一部分需要异步执行，一部分可以同步执行的情况。
-n，--nb, --nonblock：非阻塞模式，当获取锁失败时，返回1而不是等待
-w, --wait, --timeout seconds：设置阻塞超时，当超过设置的秒数时，退出阻塞模式，返回1，并继续执行后面的语句
-o, --close：表示当执行command前关闭设置锁的FD，以使command的子进程不保持锁。
-c, --command command：在shell中执行其后的语句
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;最后&lt;/h2&gt;

&lt;p&gt;flock可以让很多脚本程序变得更规范，比如我有一些增量计算数据的脚本，如果不小心并发执行了就会导致数据错乱。&lt;/p&gt;

&lt;p&gt;以前不知道这个命令，都是用一个lock文件来替代，在脚本中判断文件是否存在，非常的繁琐，也不是很严谨。&lt;/p&gt;

&lt;p&gt;你是更喜欢把flock放在脚本外部，还是写在脚本里呢？&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Jun 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-06-13-flock</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-06-13-flock</guid>
        
        
        <category>shell</category>
        
        <category>lock</category>
        
      </item>
    
      <item>
        <title>CMD</title>
        <description>&lt;p&gt;使用linux的命令时，经常会用man来查询可选参数及其含义。偶尔我们也会开发自己的小工具。&lt;/p&gt;

&lt;p&gt;如何给小工具快速添加可选参数呢？&lt;/p&gt;

&lt;h2 id=&quot;java&quot;&gt;java&lt;/h2&gt;

&lt;p&gt;java的开发者应该是更喜欢使用配置文件的方式来与程序交互，无论是property还是yml。&lt;/p&gt;

&lt;p&gt;在参数不是特别多时，cmd的params也是不错的选择。提到给java传参数，大多数人一定是会&lt;/p&gt;

&lt;p&gt;想到main函数的args数组，这是基础，但不太方便。&lt;/p&gt;

&lt;p&gt;推荐使用commons-cli，能够设定长短参数(-i 或 –interval)，还能添加注解。&lt;/p&gt;

&lt;p&gt;具体的方法我就不展开讲了，网上能搜到很多。&lt;/p&gt;

&lt;h2 id=&quot;getopts&quot;&gt;getopt(s)&lt;/h2&gt;

&lt;p&gt;shell中最普遍的解决办法就是getopt，配合while case处理输入的参数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while getopts 'h:j:m:u' OPT;do
    case $OPTin
        j) S_DIR=&quot;$OPTARG&quot;;;
        m) D_DIR=&quot;$OPTARG&quot;;;
        u) upload=&quot;true&quot;;;
        h) func;;
        ?) func;;
    esac
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如何你想实现tab自动提示的话，可以了解一下_get_comp_words_by_ref。&lt;/p&gt;

&lt;h2 id=&quot;shell&quot;&gt;shell默认的参数处理&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
$0 : 脚本名
$N : 第N个参数.
$# : 参数的个数，不包括命令本身.
$@ : 参数本身的列表，也不包括命令本身，如上例为 -v -f -out /test.log –prefix=/home
$* : 参数本身的列表，也不包括命令本身，但”$*” 和”\$@”(加引号)并不同，”$*“将所有的参数解释成一个字符串，而”$@”是一个参数数组。

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种处理方法没有getopt简洁，一般还是推荐使用getopt。但是下面这个特殊用法需要注意一下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&quot;${@:2}&quot;  从第二参数开始往后的所有参数

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 20 May 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-05-20-CMD</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-05-20-CMD</guid>
        
        
        <category>cmd</category>
        
        <category>shell</category>
        
      </item>
    
      <item>
        <title>UniswapOracle</title>
        <description>&lt;p&gt;这次聊聊Uniswap的预言机，上次我们介绍的Chainlink属于通用预言机。&lt;/p&gt;

&lt;p&gt;在Uniswap项目中，内置了一个预言机功能，算是专用吧，具有一定的特殊性。&lt;/p&gt;

&lt;h2 id=&quot;uniswap&quot;&gt;Uniswap&lt;/h2&gt;

&lt;p&gt;Uniswap最近一年非常的火热，算是Defi的基石项目了。随着其V3版本的发布，&lt;/p&gt;

&lt;p&gt;会吸引越来越多的做市商。这里介绍一个&lt;a href=&quot;https://liaoph.com/&quot;&gt;Blog&lt;/a&gt;。可以作为Uniswap的入门资料。&lt;/p&gt;

&lt;h2 id=&quot;uniswaporacle&quot;&gt;Uniswap的Oracle&lt;/h2&gt;

&lt;p&gt;之前讲的Chainlink的预言机，使用者大多关注当前价格，少量场景也需要历史价格。&lt;/p&gt;

&lt;p&gt;Uniswap的Oracle是提供时间加权平均价，并且可以随意指定周期。设计出这样的Oracle，&lt;/p&gt;

&lt;p&gt;主要是为了抵御价格操纵闪电贷之类的攻击。在目前的Defi项目中，这类需求还是比较普遍的。&lt;/p&gt;

&lt;p&gt;我个人觉得Uniswap的Oracle时间加权思路是不错的，但不适合普及使用。比如标的非常有限、&lt;/p&gt;

&lt;p&gt;存储数据的精度问题等等。但是提供的按照时间二分查找的功能是Chainlink所缺少的。&lt;/p&gt;

&lt;h2 id=&quot;ema&quot;&gt;通用化EMA指标预言机&lt;/h2&gt;

&lt;p&gt;在清算类的业务中，一般使用指数类的价格，比如MA、EMA。期货合约的清算逻辑，&lt;/p&gt;

&lt;p&gt;用来计算是否强制平仓的价格，就不会使用现货的当前价格，一般是EMA(5min)之类的。&lt;/p&gt;

&lt;p&gt;主要是为了削弱价格剧烈波动导致的连锁爆仓反应。&lt;/p&gt;

&lt;p&gt;如果提供一种类似EMA计算的指标价格预言机，我相信会对清算类的业务非常友好。&lt;/p&gt;

&lt;p&gt;可以沿用现有预言机的大部分接口，没有数据精度问题，可轻松获取历史轨迹，作为独立&lt;/p&gt;

&lt;p&gt;计算存储的合约，不与其他项目绑定，可重复利用现有“共识”预言机的结果，保证准确。&lt;/p&gt;

&lt;p&gt;当然这样的方案相对Uniswap的Oracle会缺少一个周期的灵活性，但我个人认为这个不是&lt;/p&gt;

&lt;p&gt;十分重要，大多数项目需要的周期都是可以协调的，而且固定。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;最后&lt;/h2&gt;

&lt;p&gt;预言机的话题就告一段落，这个领域也算是刚刚起步，Chainlink也在快速发展中，希望能够&lt;/p&gt;

&lt;p&gt;有更开放的社区，可以有更多的协作模式，让开发者参与共建。&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Apr 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-04-27-UniswapOracle</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-04-27-UniswapOracle</guid>
        
        
        <category>Uniswap</category>
        
        <category>Oracle</category>
        
      </item>
    
      <item>
        <title>Chainlink</title>
        <description>&lt;p&gt;Chainlink目前已经是预言机领域里的顶流项目，无论是经济模型还是架构设计&lt;/p&gt;

&lt;p&gt;都非常值得学习的。&lt;/p&gt;

&lt;h2 id=&quot;oracle&quot;&gt;预言机Oracle&lt;/h2&gt;

&lt;p&gt;因为以太坊区块链上无法发起对外部世界的请求，也就是无法直接获取外部数据，&lt;/p&gt;

&lt;p&gt;极大的限制了智能合约的使用范围。将外部数据引入区块链世界，就是预言机的职能，&lt;/p&gt;

&lt;p&gt;将拉取数据变为推送数据，保存在合约里。这一点与流计算中的恰好一次，其实是&lt;/p&gt;

&lt;p&gt;非常相似的问题。如果你想让流计算可以反复执行，且结果是恰好一次的，那需要&lt;/p&gt;

&lt;p&gt;严格控制堆外的依赖，比如Redis的计数器、外部系统的实时数据接口等。&lt;/p&gt;

&lt;p&gt;解决外部依赖问题时，经常是将外部数据写入流中（或join）、在流引擎内保存状态。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;成本问题&lt;/h2&gt;

&lt;p&gt;改为推送数据模式后，面临极大的成本问题。如果数据频繁发生变化，那就需要不断调用&lt;/p&gt;

&lt;p&gt;合约的更新方法。但链上业务使用数据并不一定那么频繁。或者是某些数据使用不太频繁。&lt;/p&gt;

&lt;p&gt;这个成本问题就极大的制约了预言机服务的范围，目前看几个主流预言机项目提供的数据&lt;/p&gt;

&lt;p&gt;总共也不超过100种。而且更新频率都不是很高，一般10分钟左右。&lt;/p&gt;

&lt;p&gt;除了写入成本以外，还有共识成本。比如早期的Chainlink所有节点都会把数据上报到合约中，&lt;/p&gt;

&lt;p&gt;最后算一个中位数。每一轮都会有20个左右的节点参与。相当于把写入成本放大了20倍。&lt;/p&gt;

&lt;p&gt;当然现在的Chainlink OCR已经把这个问题解决了，思路就是把共识环节放在低成本链去实现。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;共识问题&lt;/h2&gt;

&lt;p&gt;预言机的数据真的可以依靠共识来解决么？这是个非常值得讨论的话题，虽然共识是区块链&lt;/p&gt;

&lt;p&gt;类型的项目惯用的手法。但很多都是生搬硬套来的，并不是很恰当。API3项目的思路也不错，&lt;/p&gt;

&lt;p&gt;预言机的数据由可信的权威机构来提供，绕过了关于数据正确的证明过程，只解决可用性问题。&lt;/p&gt;

&lt;p&gt;Chainlink是依靠质押处罚、门限签名等手段来防止数据错误，再最新的计划里还将引入一些&lt;/p&gt;

&lt;p&gt;博弈论的思路，比如囚徒困境等，增加被攻击的难度。显然这些手段都是有一定积极效果的，&lt;/p&gt;

&lt;p&gt;但是为此付出的成本也是极大的，我个人并不看好这种发展思路。Chainlink未来的计划还是&lt;/p&gt;

&lt;p&gt;很值得期待的，主要是在零知识证明方向上，可信计算和验证等技术。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;服务模式&lt;/h2&gt;

&lt;p&gt;Chainlink采用的技术以去中心化为主，但是运用模式还是一个典型的中心化模式。&lt;/p&gt;

&lt;p&gt;毕竟当前还是处于发展的早期阶段，希望未来的Chainlink可以越来越自由化。&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Mar 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-03-16-chainlink</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-03-16-chainlink</guid>
        
        
        <category>chainlink</category>
        
      </item>
    
      <item>
        <title>ETH合约</title>
        <description>&lt;p&gt;最近开始接触了一下ETH的智能合约，主要是通过Chainlink这个优秀的预言机项目。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;合约的特点&lt;/h2&gt;

&lt;p&gt;ETH上的合约主要是用Solidity语言来开发的，使用下来感觉语言本身还不是很成熟，&lt;/p&gt;

&lt;p&gt;数据结构比较单一，适合实现简单的计算逻辑和数据存储。&lt;/p&gt;

&lt;p&gt;与其他开发项目相比，代码一旦发布后很难修改，代码“性能”需要特别关注。&lt;/p&gt;

&lt;p&gt;合约代码在执行过程中依据Op来计算需要消耗的gas费，所以代码的质量非常关键。&lt;/p&gt;

&lt;p&gt;在我们了解Chainlink项目和开发自己的合约时碰到了下面几个案例，分享一下。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;写入与更新&lt;/h3&gt;

&lt;p&gt;Chainlink的历史数据是保存在合约的一个Map中，key是roundid，value是价格。&lt;/p&gt;

&lt;p&gt;在我们测试Map的写入与更新时发现，第一次写入某一个key和后面更新key的Value，&lt;/p&gt;

&lt;p&gt;费用差距是巨大的，大概是2倍左右。我们在设计类似保存历史数据的环节时，采用了&lt;/p&gt;

&lt;p&gt;循环key值，比如自增ID对1024取模，这样只有第一轮是insert，第1025次之后就是&lt;/p&gt;

&lt;p&gt;update了，费用会降低下来，在合约里只能查询一段时间的历史记录，之前的会被覆盖。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;代理&lt;/h3&gt;

&lt;p&gt;因为链上的合约一旦部署成功后，就不能修改了，如果想要升级就要使用新的合约地址了，&lt;/p&gt;

&lt;p&gt;这对外部依赖是非常不友好的。参考Chainlink和Openzapplin项目，一般都是采用代理&lt;/p&gt;

&lt;p&gt;模式将接口和实现解耦和，接口层记录了实现合约的地址，提供一个Update实现合约地址的&lt;/p&gt;

&lt;p&gt;方法，进行替换，来达到升级的目的。虽然可以实现，但是开发时非常繁琐。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;存储与计算分离&lt;/h3&gt;

&lt;p&gt;上面提到了升级的问题，如果你的合约里还保存了一些数据，那么在升级时也需要将其转移到&lt;/p&gt;

&lt;p&gt;新的合约里。部署合约是有费用成本的，如果在部署合约时，涉及到了大量的数据copy，&lt;/p&gt;

&lt;p&gt;这个成本会变得非常昂贵。代理模式只是解决了升级当中的持续稳定服务问题，在设计合约时，&lt;/p&gt;

&lt;p&gt;还需要将合约里的存储结构和计算逻辑进行解耦，一般我们只对计算逻辑进行升级，而存储部分&lt;/p&gt;

&lt;p&gt;不会移动，仅仅会修改一些写权限的控制，将新合约地址更新到存储数据的合约中去。&lt;/p&gt;
</description>
        <pubDate>Mon, 22 Feb 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-02-22-contract</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-02-22-contract</guid>
        
        
        <category>contract</category>
        
      </item>
    
  </channel>
</rss>
