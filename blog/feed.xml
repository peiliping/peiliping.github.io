<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://peiliping.github.io/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://peiliping.github.io/blog/" rel="alternate" type="text/html" /><updated>2022-12-27T19:29:27+08:00</updated><id>http://peiliping.github.io/blog/feed.xml</id><title type="html">Pei LiPing’s Blog</title><subtitle>有一天你走出腐烂的象牙塔门， 成为那漂浮不定的孤寂灵魂。 四处搜寻着安身的墓地坑坟， 刻画和擦拭着自己的墓志铭文。</subtitle><entry><title type="html">Awk Json Parser</title><link href="http://peiliping.github.io/blog/2022/09/02/jsonparser.html" rel="alternate" type="text/html" title="Awk Json Parser" /><published>2022-09-02T10:00:00+08:00</published><updated>2022-09-02T10:00:00+08:00</updated><id>http://peiliping.github.io/blog/2022/09/02/jsonparser</id><content type="html" xml:base="http://peiliping.github.io/blog/2022/09/02/jsonparser.html"><![CDATA[<p>Awk主要是用于文本数据处理的，而且主要是CSV格式。如果你碰到要处理Json数据，</p>

<p>就会比较麻烦。Awk原生没有提供Json的解析方法，可以加一个rapidjson的exlib。</p>

<p>rapidjson我在logwatch的项目中使用过，性能极佳。也许有人会想为什么不用jq呢，</p>

<p>如果awk的运算逻辑比较复杂的话，用jq解析是不现实的，还是需要操作一个awk的原生</p>

<p>数组，才能完全发挥awk的能力。</p>

<p>Github上有一个基于awk实现的<a href="https://github.com/step-/JSON.awk">JsonParser</a>。</p>

<p>本着造轮子要造多个的基本原则，我也来凑个热闹，做个精简版的。</p>

<h3 id="元素">元素</h3>

<ol>
  <li>
    <p>String</p>
  </li>
  <li>
    <p>Number</p>
  </li>
  <li>
    <p>Boolean</p>
  </li>
  <li>
    <p>Array</p>
  </li>
  <li>
    <p>Object(key-values)</p>
  </li>
</ol>

<h3 id="逻辑关系">逻辑关系</h3>

<p>按照Lpeg表达式的风格来写一下</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Element = (String or Number or Boolean or Array or Object)

Array = [ Element , Element ...]

Key = String 

Object = { Key : Element , Key : Element ...}

JSON = (Array or Object)

</code></pre></div></div>

<h3 id="元素类型的判断依据">元素类型的判断依据</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  if(_sp == "\""){return "string";}
  if(_sp ~ /[0-9\-]/){return "number";}
  if(_sp == "t" || _sp == "f"){return "boolean";}
  if(_sp == "["){return "array";}
  if(_sp == "{"){return "object";}

</code></pre></div></div>

<h3 id="完整代码">完整代码</h3>

<p>一个80行的JsonParser，简单明了。</p>

<p>说一个Awk的大坑，awk的变量是不能声明为local的，所以使用变量要非常慎重。</p>

<p>一旦需要local var，就要在函数params里声明一个虚参。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function fatal(_sp){ print "fatal error !!! index : ("IDX") "_sp; exit 1; }
function get(_np){ return substr(JSON_STRING, IDX, _np); }
function step(_np){ IDX+=_np; }
function skip(_sp, _greed){
  if(get(length(_sp)) == _sp){ 
    step(length(_sp)); 
    if(_greed == "true"){ skip(_sp, _greed); }
  } 
}
function skipSpace(){ skip(" ", "true" ); }
function skipDot(){ skip(",", "false"); }
function check(_sp){ 
  if(get(length(_sp)) == _sp){ step(length(_sp)); return ; }
  fatal("check failed "_np);  
}
function keyfc(_key, _i){
  for(_i = IDX; ; _i++){ if(substr(JSON_STRING, _i, 1) == "\""){ break; } }
  _key = get(_i - IDX); step(_i - IDX + 1); return _key;
}
function strfc(_json, _key, _i){
  for(_i = IDX; ; _i++){ if(substr(JSON_STRING, _i, 1) == "\"" &amp;&amp; substr(JSON_STRING, _i - 1, 1) != "\\"){ break; } }
  _json[_key] = get(_i - IDX); step(_i - IDX + 1);
}
function numfc(_json, _key, _i){
  for(_i = IDX; ; _i++){ if(substr(JSON_STRING, _i, 1) !~ /[0-9.\-]/){ break; } }
  _json[_key] = get(_i - IDX); step(_i - IDX);
}
function boolfc(_json, _key){
  if(get(4) == "true" ){ _json[_key] = "true";  step(4); return; }
  if(get(5) == "false"){ _json[_key] = "false"; step(5); return; }
  fatal("not boolean");
}
function arrfc(_json, _key){
  _key = 0;
  while(1 == 1){
    skipSpace();
    if(get(1) == "]"){ step(1); skipSpace(); break; }
    if(get(1) == ","){ _json[_key++] = ""; skipDot(); continue; }
    dispatch(_json, _key++); skipSpace();
    if(get(1) != "]"){ check(","); }
  }
}
function objfc(_json, _key){
  while(1 == 1){
    skipSpace();
    if(get(1) == "}"){ step(1); skipSpace(); break; }
    check("\""); _key = keyfc(); skipSpace(); check(":"); skipSpace();
    dispatch(_json, _key); skipSpace();
    if(get(1) != "}"){ check(","); }
  }
}
function jtype(_sp){
  if(_sp == "\""){return "string";}
  if(_sp ~ /[0-9\-]/){return "number";}
  if(_sp == "t" || _sp == "f"){return "boolean";}
  if(_sp == "["){return "array";}
  if(_sp == "{"){return "object";}
  fatal("bad format");
}
function dispatch(_json, _key, _sp){
  _sp = jtype(get(1));
  if(_sp == "array"){
    if(_key == ""){
      _json["_type_"] = "array";  step(1); arrfc(_json);
    }else{
      _json[_key]["_type_"] = "array";  step(1); arrfc(_json[_key]);
    }
  }else if(_sp == "object"){
    if(_key == ""){
      _json["_type_"] = "object"; step(1); objfc(_json);
    }else{
      _json[_key]["_type_"] = "object"; step(1); objfc(_json[_key]);
    }
  }else if(_sp == "string"){
    step(1); strfc(_json, _key);
  }else if(_sp == "number"){
    numfc(_json, _key);
  }else if(_sp == "boolean"){
    boolfc(_json, _key);
  }
}
function parserJson(_str, _json){
 JSON_STRING = _str; IDX = 1; skipSpace();
 rootType = jtype(get(1)); if(rootType != "array" &amp;&amp; rootType != "object"){ fatal("not json"); }
 dispatch(_json);
}

</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[Awk主要是用于文本数据处理的，而且主要是CSV格式。如果你碰到要处理Json数据，]]></summary></entry><entry><title type="html">Expect SSH</title><link href="http://peiliping.github.io/blog/2022/05/12/expectssh.html" rel="alternate" type="text/html" title="Expect SSH" /><published>2022-05-12T10:00:00+08:00</published><updated>2022-05-12T10:00:00+08:00</updated><id>http://peiliping.github.io/blog/2022/05/12/expectssh</id><content type="html" xml:base="http://peiliping.github.io/blog/2022/05/12/expectssh.html"><![CDATA[<p>提到自动登录ssh的时候，最好还是使用秘钥登录，当然也可以使用expect。</p>

<p>下面介绍几个expect和ssh的例子。</p>

<h3 id="login">login</h3>

<p>-p是指定远程的端口。</p>

<p>interact执行完成后保持交互状态，把控制权交给控制台，这个时候就可以手工操作了。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
spawn ssh -o ServerAliveInterval=60 -p 11111 username@ip
expect "*password:"
send "Password\r"
interact

</code></pre></div></div>

<h3 id="proxy">proxy</h3>

<p>当需要使用ssh做socket代理的写法，在本地开一个10001的端口。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
spawn ssh -N -g -o ServerAliveInterval=60 -D 10001 -p 11111 username@ip
expect "*password:"
send "Password\r"
interact

</code></pre></div></div>

<h3 id="login-by-proxy">login by proxy</h3>

<p>通过一个本地的代理端口10000来登录ssh。</p>

<p>nc的-X 5是指定Socks V5，-x 是指定代理地址。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
spawn ssh -o ServerAliveInterval=60 -o "ProxyCommand=nc -X 5 -x 127.0.0.1:10000 %h %p" -p 11111 username@ip
expect "*password:"
send "Password\r"
interact

</code></pre></div></div>

<h3 id="proxy-by-proxy">proxy by proxy</h3>

<p>将上面的命令组合一下就好了。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
spawn ssh -N -g -o ServerAliveInterval=60 -o "ProxyCommand=nc -X 5 -x 127.0.0.1:10000 %h %p" -D 10001 -p 11111 username@ip
expect "*password:"
send "Password\r"
interact

</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[提到自动登录ssh的时候，最好还是使用秘钥登录，当然也可以使用expect。]]></summary></entry><entry><title type="html">Awk Functions</title><link href="http://peiliping.github.io/blog/2022/04/22/awklib.html" rel="alternate" type="text/html" title="Awk Functions" /><published>2022-04-22T10:00:00+08:00</published><updated>2022-04-22T10:00:00+08:00</updated><id>http://peiliping.github.io/blog/2022/04/22/awklib</id><content type="html" xml:base="http://peiliping.github.io/blog/2022/04/22/awklib.html"><![CDATA[<p>最近写Awk比较多，所以写了一些便于自己使用的函数。</p>

<h3 id="print">Print</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
function printX(o, _indent, _x){
  if(typeof(o) != "array"){ print o; return; }
  for(_x in o){
    if(typeof(o[_x]) != "array"){
      print _indent, _x, ":", o[_x];
    }else{
      print _indent, _x, ":";
      printX(o[_x], _indent"  ");
    }
  }
}

</code></pre></div></div>

<p>打印嵌套结构的Awk Array，方便调试查看。</p>

<h3 id="clone">Clone</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
function clone(ma, mb, _key, _x){
  for(_x in ma){
    if(typeof(ma[_x]) != "array"){
      if(_key == ""){
        mb[_x] = ma[_x];
      }else{
        mb[_key][_x] = ma[_x];
      }
    }else{
       if(_key == ""){
         clone(ma[_x], mb, _x);
       }else{
         clone(ma[_x], mb[_key], _x);
       }
    }
  }
}

</code></pre></div></div>

<p>Clone就是一个递归函数，没有什么特别的。为什么要给Awk实现一个Clone函数呢？</p>

<p>因为Awk无法做这样的赋值操作,当map[a]是Array时，b = map[a]会报错,</p>

<p>错误提示为：试图在标量环境中使用数组“map[a]”。这时候我们可以用clone(map[a],b)来替代。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[最近写Awk比较多，所以写了一些便于自己使用的函数。]]></summary></entry><entry><title type="html">Binance Spot Client</title><link href="http://peiliping.github.io/blog/2022/03/11/BinanceSpotClient.html" rel="alternate" type="text/html" title="Binance Spot Client" /><published>2022-03-11T10:00:00+08:00</published><updated>2022-03-11T10:00:00+08:00</updated><id>http://peiliping.github.io/blog/2022/03/11/BinanceSpotClient</id><content type="html" xml:base="http://peiliping.github.io/blog/2022/03/11/BinanceSpotClient.html"><![CDATA[<p>上期我们把BinanceApi的请求签名进行了封装，接下来我们就在这个基础上，实现核心功能。</p>

<h3 id="client">Client</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
getAssets(){
  local path="/sapi/v3/asset/getUserAsset"
  sendRequest "POST" $Host $path
  [[ $? -gt  0 ]] &amp;&amp; return 1
  echo $HttpResult | awk -i ${AwkLib}/json.awk '
  {
    parserJson($0, json);
    for(i=0; i&lt;length(json)-1; i++){
      print json[i]["asset"]"\t"json[i]["free"]"\t"json[i]["locked"];
    }
  }' | sort -k2nr
}

getOpenOrders(){
  local path="/api/v3/openOrders"
  sendRequest "GET" $Host $path
  [[ $? -gt  0 ]] &amp;&amp; return 1
  echo $HttpResult | awk -i ${AwkLib}/json.awk '{parserJson($0, json);printJson(json);}'
}

getOrder(){
  local path="/api/v3/order"
  local symbol=`echo $1 | tr a-z A-Z`
  local key=`getOrderIdType $2`
  local value=$2
  local params="symbol=${symbol}&amp;${key}=${value}"
  sendRequest "GET" $Host $path $params
  [[ $? -gt  0 ]] &amp;&amp; return 1
  echo $HttpResult | awk -i ${AwkLib}/json.awk '{parserJson($0, json);printJson(json);}'
}

cancelOpenOrder(){
  local path="/api/v3/order"
  local symbol=`echo $1 | tr a-z A-Z`
  local key=`getOrderIdType $2`
  local value=$2
  local params="symbol=${symbol}&amp;${key}=${value}"
  sendRequest "DELETE" $Host $path $params
  [[ $? -gt  0 ]] &amp;&amp; return 1
  echo $HttpResult | awk -i ${AwkLib}/json.awk '{parserJson($0, json);printJson(json);}'
}

marketTrade(){
  local path="/api/v3/order"
  local symbol=`echo $1 | tr a-z A-Z`
  local side=$2
  local quantity=$3
  local params="symbol=${symbol}&amp;side=${side}&amp;type=MARKET&amp;quantity=${quantity}"
  sendRequest "POST" $Host $path $params
  [[ $? -gt  0 ]] &amp;&amp; return 1
  echo $HttpResult | awk -i ${AwkLib}/json.awk '{parserJson($0, json);printJson(json);}'
}

limitTrade(){
  local path="/api/v3/order"
  local symbol=`echo $1 | tr a-z A-Z`
  local side=$2
  local price=$3
  local quantity=$4
  local params="symbol=${symbol}&amp;side=${side}&amp;type=LIMIT&amp;timeInForce=GTC&amp;price=${price}&amp;quantity=${quantity}"
  sendRequest "POST" $Host $path $params
  [[ $? -gt  0 ]] &amp;&amp; return 1
  echo $HttpResult | awk -i ${AwkLib}/json.awk '{parserJson($0, json);printJson(json);}'
}

</code></pre></div></div>

<p>总的来说还是比较简单的，预处理一下参数，解析一下返回结果的json，按照一定的格式输出。</p>

<p>U本位合约的Api也是差不多的情况，逻辑基本相同。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[上期我们把BinanceApi的请求签名进行了封装，接下来我们就在这个基础上，实现核心功能。]]></summary></entry><entry><title type="html">Cmd Binance Client</title><link href="http://peiliping.github.io/blog/2022/02/19/CmdBinanceClient.html" rel="alternate" type="text/html" title="Cmd Binance Client" /><published>2022-02-19T10:00:00+08:00</published><updated>2022-02-19T10:00:00+08:00</updated><id>http://peiliping.github.io/blog/2022/02/19/CmdBinanceClient</id><content type="html" xml:base="http://peiliping.github.io/blog/2022/02/19/CmdBinanceClient.html"><![CDATA[<p>无意间在Binance的ApiDoc中看到了基于Curl的示例代码，于是便想封装一个基于Curl的</p>

<p>命令行客户端 。获取一般行情的Api接口直接使用Curl就可以，难题主要是获取个人数据</p>

<p>和交易行为接口,需要对参数进行签名。</p>

<h3 id="client">Client</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
ApiKey="zzzzzzzzzzzzzzzzzzzz"
SecretKey="xxxxxxxxxxxxxxxxx"

HttpCode=""
HttpResult=""

## 对参数数据进行签名
signature(){
  echo -n "$1" | openssl dgst -sha256 -hmac "${SecretKey}" | awk '{print "signature="$2}'
}

## 添加时间校对参数
addTimeParams(){
  local tsParams="recvWindow=10000&amp;timestamp="`date +%s`"000"
  if [ -z "$1" ] ;then
    echo $tsParams
  else
    echo $1"&amp;"$tsParams
  fi
}

## 发送带签名的请求
sendRequest(){
  HttpCode=""
  HttpResult=""
  local method=$1
  local host=$2
  local path=$3
  local params=$4
  params=`addTimeParams ${params}`
  local sig=`signature ${params}`
  params=$params"&amp;"$sig
  local result=`curl -s -w "\t%{http_code}" -H "X-MBX-APIKEY: ${ApiKey}" -X ${method} $host""$path"?"$params`
  HttpCode=`echo $result | awk '{ print $NF}'`
  HttpResult=`echo $result | awk '{ print substr($0,1,length($0)-4); }'`
  if [ $HttpCode -eq 200 ];then
    return 0
  else
    echo $HttpResult
    return 1
  fi
}

</code></pre></div></div>

<p>签名的方法其实很简单，需要注意的是echo的参数-n，是不换行输出的意思。</p>

<p>如果不加这个参数，那么签名数据就无法通过Server端的校验了。</p>

<p>时间校对参数这里只是简单的用了当前时间，如果是谨慎设计的话，应该使用业务时间。</p>

<p>比如获取行情信息后下单，那么下单的校对时间应该是获取行情的时间。</p>

<p>如何获得Http的Code？curl默认是返回Http Response Body的，通过-w参数，</p>

<p>可以获取httpcode，会输出到最后，通过awk将其切分成Code和Result变量。</p>

<p>根据HttpCode来确定函数sendRequest的return值(0/1)。</p>

<p>我们来调用一下这个Client。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  local host="https://xxxxx.com"
  local path="/sapi/v3/asset/getUserAsset"
  sendRequest "POST" $host $path
  [[ $? -gt  0 ]] &amp;&amp; return 1
  echo $HttpResult

</code></pre></div></div>

<p>判断sendRequest的return值，如果大于0，则是请求失败，程序终止。</p>

<p>[[ $? -gt  0 ]] &amp;&amp; return 1 是一种if语句的简洁写法。</p>

<h3 id="shell中如何识别number类型">Shell中如何识别Number类型</h3>

<p>网上可以搜到很多种，我比如喜欢下面的这个方法</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  expr $1 "+" 1 &amp;&gt; /dev/null
  if [ $? -eq 0 ];then
    echo "orderId"
  else
    echo "origClientOrderId"
  fi

</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[无意间在Binance的ApiDoc中看到了基于Curl的示例代码，于是便想封装一个基于Curl的]]></summary></entry><entry><title type="html">Awk Linear</title><link href="http://peiliping.github.io/blog/2022/01/11/awklinear.html" rel="alternate" type="text/html" title="Awk Linear" /><published>2022-01-11T10:00:00+08:00</published><updated>2022-01-11T10:00:00+08:00</updated><id>http://peiliping.github.io/blog/2022/01/11/awklinear</id><content type="html" xml:base="http://peiliping.github.io/blog/2022/01/11/awklinear.html"><![CDATA[<p>上期讲到了Linear的概念，这次我们就用Awk来实现一个Linear吧。</p>

<h3 id="代码">代码</h3>

<p>下面这段代码是从TradingView的LR脚本中翻译过来的，也是我找到的比较简洁的一个版本。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
function lr(_source, _result, _i){
  _result["len"] = length(_source);
  for(_i = 1; _i &lt;= _result["len"]; _i++){
    _result["sumx"]+=_i;
    _result["sumy"]+=_source[_i];
    _result["sumxx"]+=(_i * _i);
    _result["sumxy"]+=(_i * _source[_i]);
  }
  _result["slope"] = (_result["len"] * _result["sumxy"] - _result["sumx"] * _result["sumy"]) / (_result["len"] * _result["sumxx"] - _result["sumx"] * _result["sumx"]);
  _result["intercept"] = _result["sumy"] / _result["len"] - _result["slope"] * _result["sumx"] / _result["len"] + _result["slope"];
 
  for(_i = 1; _i &lt;= _result["len"]; _i++){
    _result["stdDevAcc"]+=((_i * _result["slope"] + _result["intercept"] - _source[_i]) * (_i * _result["slope"] + _result["intercept"] - _source[_i]));
  }
  _result["stdDev"] = sqrt(_result["stdDevAcc"] / (_result["len"] - 1));
  _result["M"] = _result["len"] * _result["slope"] + _result["intercept"];
  _result["U"] = _result["M"] + 2 * _result["stdDev"];
  _result["D"] = _result["M"] - 2 * _result["stdDev"];
}

</code></pre></div></div>

<p>返回结果一般主要是获取slope、intercept、stdDev，还有U、M、D。</p>

<h3 id="关于awk加载functions的问题">关于awk加载functions的问题</h3>

<p>如果你写了一个完整的awk脚本可以通过参数 -f 来执行script，例如： <code class="language-plaintext highlighter-rouge">awk -f xxx.awkscript</code></p>

<p>如果你只是向上面LR一样实现了一个函数，希望能够被复用的话，可以这样：</p>

<p><code class="language-plaintext highlighter-rouge">awk -i lib.awkscript  '{ lr(source, result); print result["M"];}'</code></p>

<p>如果你有多个lib文件的话，可以多次使用 -i  <code class="language-plaintext highlighter-rouge">-i a.awk -i b.awk -i c.awk</code></p>

<p>还可以再script文件里使用 @include 进行文件或者目录的加载，有点像模板加载宏。</p>

<h3 id="关于awk中array的赋值问题">关于awk中Array的赋值问题</h3>

<p>awk的Array和Lua的Table特性非常相似，但是Awk没有提供像ipairs这样的迭代工具。</p>

<p>Array也无法成为Awk函数的返回值，只能在参数中传递进来，参考awk中split的用法。</p>

<p>如果map[“key”]也是Array的话，无法直接进行变量的赋值，比如：val = map[“key”]。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[上期讲到了Linear的概念，这次我们就用Awk来实现一个Linear吧。]]></summary></entry><entry><title type="html">Linear</title><link href="http://peiliping.github.io/blog/2021/12/29/linear.html" rel="alternate" type="text/html" title="Linear" /><published>2021-12-29T10:00:00+08:00</published><updated>2021-12-29T10:00:00+08:00</updated><id>http://peiliping.github.io/blog/2021/12/29/linear</id><content type="html" xml:base="http://peiliping.github.io/blog/2021/12/29/linear.html"><![CDATA[<p>经常看到一些人的K线图上花了很多辅助线，有压力支撑，也有涨跌趋势。</p>

<p>今天介绍一种自动化斜线的方法，平行斜线通道。</p>

<h3 id="中轴线">中轴线</h3>

<p>最近N个K线点，有一个趋势方向，由这些点的分布决定，比如震荡向上，</p>

<p>这是我们在头脑中抽象的画面，需要将他们具体化。</p>

<p>在二维坐标系中，已知一些点，如何判断他们内在隐含的趋势呢？</p>

<p>这个问题在数学中非常简单，那就是一次方程(y=ax+b)的拟合过程。</p>

<p>如果这部分知识已经还给老师的话，先复习一下最小二乘法吧。</p>

<p>计算完成后，我们将得到方程的参数slope和intercept。</p>

<h3 id="平行线">平行线</h3>

<p>将我们得到的中轴线进行平移，使绝大多数点都在线的上方（或者下方），</p>

<p>就会得到一组平行于中轴线的通道了。</p>

<p>那么这个平移的过程如何计算呢？可以参考Bolling指标的计算方法，</p>

<p>我们先求所有散点与中轴线的标准差，然后将中轴线的方程向上（或向下）</p>

<p>移动2个标准差的距离，就得到了一组平行于中轴线的平行通道了。</p>

<p>就是保持slope不变，intercept加（或者减）2×标准差。</p>

<h3 id="周期">周期</h3>

<p>搞定了计算逻辑后，最后一个问题就是周期问题了，选择多少个点呢？</p>

<p>没有哪一个周期是绝对有效的，按照自己的操作周期来决定吧。</p>

<p>和使用均线等技术指标差不多，可以同时看长短两个周期的数据，一个定方向，一个找机会。</p>

<h3 id="最后">最后</h3>

<p>自动化线并不能指导你盈利，但可以减少盯盘时间，如果是自动化交易作为增减仓方案是不错的。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[经常看到一些人的K线图上花了很多辅助线，有压力支撑，也有涨跌趋势。]]></summary></entry><entry><title type="html">Pine</title><link href="http://peiliping.github.io/blog/2021/11/20/pine.html" rel="alternate" type="text/html" title="Pine" /><published>2021-11-20T10:00:00+08:00</published><updated>2021-11-20T10:00:00+08:00</updated><id>http://peiliping.github.io/blog/2021/11/20/pine</id><content type="html" xml:base="http://peiliping.github.io/blog/2021/11/20/pine.html"><![CDATA[<p>最近看到Tradingview的Pine脚本，感觉很有意思，打算尝试一下。</p>

<h2 id="ma指标">MA指标</h2>

<p>TV上的指标都可以看到源代码，我们就从最简单的MA指标看看吧。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
indicator(title="Moving Average", shorttitle="MA", overlay=true, timeframe="", timeframe_gaps=true)
len = input.int(9, minval=1, title="Length")
src = input(close, title="Source")
offset = input.int(title="Offset", defval=0, minval=-500, maxval=500)
out = ta.sma(src, len)
plot(out, color=color.blue, title="MA", offset=offset)

</code></pre></div></div>

<p>简单注释一下：</p>

<p>input代表从图形化界面的设置中可以填写变更的，close指k线的收盘价。</p>

<p>ta.sma就是MA指标的计算公式，plot函数我们就理解为渲染好了,plot有很多参数可调，</p>

<p>比如控制线的粗细、颜色。</p>

<h2 id="照葫芦画瓢-mac指标">照葫芦画瓢 MAC指标</h2>

<p>第一次体验我们就不挑战难度了，弄一个MA指标的组合指标，一般使用MA的人都会用一个短周期的和一个长周期的。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
indicator(title="Moving Average Couple", shorttitle="MAC", overlay=true, timeframe="", timeframe_gaps=true)

len1 = input.int(30, minval=1, title="Length")
len2 = input.int(59, minval=1, title="Length")

out1 = ta.sma(close, len1)
out2 = ta.sma(close, len2)

plot(out1, color=color.green, linewidth=2, title="MAC1", offset=0)
plot(out2, color=color.blue, linewidth=2, title="MAC2", offset=0)

</code></pre></div></div>

<p>只是简单的加了一条线，然后控制了一下线的颜色和粗细。</p>

<p>免费版TV限制了同时使用的Indicator数量，可以把多个指标的代码合并到一起，绕过限制吧。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[最近看到Tradingview的Pine脚本，感觉很有意思，打算尝试一下。]]></summary></entry><entry><title type="html">Baby</title><link href="http://peiliping.github.io/blog/2021/10/10/birthday.html" rel="alternate" type="text/html" title="Baby" /><published>2021-10-10T10:00:00+08:00</published><updated>2021-10-10T10:00:00+08:00</updated><id>http://peiliping.github.io/blog/2021/10/10/birthday</id><content type="html" xml:base="http://peiliping.github.io/blog/2021/10/10/birthday.html"><![CDATA[<p>前几天我们家的宝宝出生了，真的是一波三折。</p>

<p>希望小豌豆健康成长，本月停更，学习换尿布去了。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[前几天我们家的宝宝出生了，真的是一波三折。]]></summary></entry><entry><title type="html">Wyckoff2</title><link href="http://peiliping.github.io/blog/2021/09/11/wyckoff2.html" rel="alternate" type="text/html" title="Wyckoff2" /><published>2021-09-11T10:00:00+08:00</published><updated>2021-09-11T10:00:00+08:00</updated><id>http://peiliping.github.io/blog/2021/09/11/wyckoff2</id><content type="html" xml:base="http://peiliping.github.io/blog/2021/09/11/wyckoff2.html"><![CDATA[<p>上一篇讲了点有关威科夫的量价理论，这里继续说一说。</p>

<h2 id="趋势与画辅助线">趋势与画辅助线</h2>

<p>无论是何门何派，画辅助线都是必须的，但是辅助线经常是主观的。</p>

<p>K线与辅助线交织在一起，经常无法做出决策。看历史怎么都对，实战中一卖就涨。</p>

<p>如果等辅助线和K线的关系明确了，那么大部分利润也就没有了。</p>

<p>威科夫理论中经常画横线作为支撑和压力线，这个方法我觉得还是比较可取的，</p>

<p>但画横线不是单纯的基于价格和图形，也是要基于成交量的。</p>

<h2 id="关于成交量">关于成交量</h2>

<p>在威科夫的理论中成交量是非常的关键，但是所有人都知道主力自己可以创造无效成交量。</p>

<p>所以一个充分博弈的标的，他的成交量才失真最小，可靠性最大。</p>

<p>至于什么主力动向数据、大单买入卖出，更是扯淡。</p>

<p>去看看操盘软件里如何买卖就知道了，这种方法根本判断不出来。</p>

<p>大单成交方向不一定代表主力方向，但是小单成交一定包含散户的趋势。</p>

<p>如果大单连续主动买入时，只与深度中的大单成交而不与散单成交，基本上就是主力在自成交。</p>

<p>大单如果想隐秘买入行为的话，一般是连下两单。第一单是LimitBuy，并且数量远超过深度中的量。</p>

<p>此单成交后会把价格拉升到LimitBuy的目标价，并且买一位置有一个很大的买单。</p>

<p>第二单为IOC Sell，价格与LimitBuy的价格相同。IOC的意思是立即成交，余下的取消。</p>

<p>这样买一的大单就被吃掉了，如果Sell的Amout大于买一的Amount，成交后余下的会被自动取消。</p>

<p>如果有人统计这一分钟里的大单的主动买入和卖出，会发现主动买入100个，主动卖出500个，</p>

<p>统计结果为主动卖出400个。而实际情况是只主动买了100个。</p>

<h2 id="压力与支撑">压力与支撑</h2>

<p>通过成交量来判断支撑与压力，我觉得也不是很合理，当然绝大部分交易者只能用成交量来判断。</p>

<p>压力与支撑本质上有两个数据组成，一个是盘口数据（也就是买卖盘深度），一个是成交明细。</p>

<p>分别举个例子：</p>

<p>1、如果有人在买一挂了一个无比巨大的买单，无形中就是一个支撑，愿意卖的人就少了。</p>

<p>2、关注已成交订单中被成交的方向，当前1h下跌2%，看似十分凶猛，但是却不继续下跌了。</p>

<p>有可能某些主力资金在这里连续的挂PostOnly单子悄悄的收货，利用恐慌的抛盘完成收货目的。</p>

<p>这种把抛盘密集消化掉的行为才是最有效的支撑，但统计却都是主动卖出行为。</p>

<p>大多数人对压力和支撑的判断基本上是意识流，我还是建议把他数值化，可以参考加权跳动量的计算方式。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[上一篇讲了点有关威科夫的量价理论，这里继续说一说。]]></summary></entry></feed>