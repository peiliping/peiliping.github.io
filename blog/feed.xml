<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pei LiPing's Blog</title>
    <description>Augur
</description>
    <link>http://peiliping.github.io/blog/</link>
    <atom:link href="http://peiliping.github.io/blog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 21 Dec 2021 20:33:52 +0800</pubDate>
    <lastBuildDate>Tue, 21 Dec 2021 20:33:52 +0800</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>Baby</title>
        <description>&lt;p&gt;前几天我们家的宝宝出生了，真的是一波三折。&lt;/p&gt;

&lt;p&gt;希望小豌豆健康成长，本月停更，学习换尿布去了。&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Oct 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-10-10-baby</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-10-10-baby</guid>
        
        
        <category>baby</category>
        
        <category>birthday</category>
        
      </item>
    
      <item>
        <title>Wyckoff</title>
        <description>&lt;p&gt;最近在和一个做二级市场投资的朋友聊天时，听说了威科夫的量价理论。&lt;/p&gt;

&lt;p&gt;在了解了大致的思想之后，我觉得当中的量价关系十分有趣，花了一些时间探索了一下。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;量价理论&lt;/h2&gt;

&lt;p&gt;K线图有两个核心元素：价格（开高低收）和成交量，价格的趋势和成交量的情况相互验证。&lt;/p&gt;

&lt;p&gt;量价理论并不是一个指标，而是一种对抗的思维。市场中存在少数派盈利的主力和盲从的韭菜，&lt;/p&gt;

&lt;p&gt;在一个大的涨跌周期中，反复对抗博弈，量与价就在表达这个对抗博弈的过程。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;关于指标&lt;/h2&gt;

&lt;p&gt;市面上绝大多数交易策略都是以XX指标组合为基础，比如均线、MACD、KDJ等。&lt;/p&gt;

&lt;p&gt;我之前也写过两期关于ta4j的blog，还实现了一个指标基础函数库。&lt;/p&gt;

&lt;p&gt;对比量价理论后，我把基于指标的策略称为静态策略，就好像诸葛亮给的三个锦囊。&lt;/p&gt;

&lt;p&gt;这种神话故事根本就不具备实操性，你可能会觉得在某个时期这个策略能挣钱，但长期一定无法盈利。&lt;/p&gt;

&lt;p&gt;有的人做了大量的回测来提高他策略的有效性，我觉得通过回测来调整参数，可以直接定义为过拟合。&lt;/p&gt;

&lt;p&gt;其实绝大多数指标和图形理论都和量价有联系，比如头肩图形、波浪理论等等。&lt;/p&gt;

&lt;p&gt;将复杂的对抗归纳成一些可被识别的图形，方便教学传播、办班收费。&lt;/p&gt;

&lt;p&gt;而且指标基本上都只用价格信息，不用成交量，因为成交量随机性太强，很难被指标化。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;充分博弈市场&lt;/h2&gt;

&lt;p&gt;如果你想践行量价理论，我个人觉得一定要找一个充分博弈的标的。&lt;/p&gt;

&lt;p&gt;成交量巨大、参与人数众多、还有很多自以为是的量化策略在跑。&lt;/p&gt;

&lt;p&gt;在这种标的下，专业机构盈利是需要极其复杂的操盘手法的，趋势惯性和量价博弈也才有意义。&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Aug 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-08-19-wyckoff</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-08-19-wyckoff</guid>
        
        
        <category>wyckoff</category>
        
      </item>
    
      <item>
        <title>write file</title>
        <description>&lt;p&gt;最近在优化一些shell脚本任务，涉及到对文件的读写过程，这里聊聊我碰到的一些问题。&lt;/p&gt;

&lt;p&gt;我的脚本主要是对数据进行统计和计算，数据具有时序性，每分钟会有一行结果存在结果文件中。&lt;/p&gt;

&lt;p&gt;脚本每分钟执行一次，每次计算上一分钟和当前分钟的结果。保存结果数据时，会涉及到删除结果文件的最后一行，因为最后一分钟会被修正。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;如何衔接两次任务的时间&lt;/h2&gt;

&lt;p&gt;数据结果的文件每一行都对应一分钟的数据，每行开头都记录对应的时间戳。&lt;/p&gt;

&lt;p&gt;每次任务开始时，都读取结果文件的末尾，计算合理的数据时间。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
thishourday=`date &quot;+%Y-%m-%d&quot;`
startTime=`date -d &quot;${thishourday}&quot; +%s`

if [ -f &quot;$rfile&quot; ]; then
  startTime=`tail -n 1 $rfile | awk '{print $1}'`
else
  touch $rfile
fi

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;dailyrolling&quot;&gt;原始数据文件有DailyRolling&lt;/h2&gt;

&lt;p&gt;这就意味着每天00:00处理数据时，需要读取前一天的文件和当天文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
starthourday=`date --date=@${startTime} &quot;+%Y-%m-%d&quot;`

if [ $starthourday = $thishourday  ];then
  dfile=$dfile
else
  dfile=$dfile&quot;-&quot;$starthourday&quot; &quot;$dfile
fi

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;保存计算结果&lt;/h2&gt;

&lt;p&gt;每次计算任务完成后，都先将数据写入临时文件tfile中，接下来我们删除结果文件的最后一行。&lt;/p&gt;

&lt;p&gt;删除我们用了一个简单的命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
sed -i '$ d' $rfile

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后我们将临时文件Merge到结果文件的末尾，删除临时文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
cat $tfile &amp;gt;&amp;gt; $rfile
rm -rf $tfile

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;性能问题&lt;/h2&gt;

&lt;p&gt;如果结果文件越来越大，这个任务会越来越慢，主要的性能问题在删除文件最后一行这一步。&lt;/p&gt;

&lt;p&gt;sed删除最后一行这样的方式，几乎等于把整个文件重写了一遍。有兴趣的朋友可以看看这篇&lt;a href=&quot;https://www.codenong.com/4881930/&quot;&gt;Blog&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我觉得出现这个问题本身就代表了设计问题，临时数据（最后一行）是否要直接写入结果文件？&lt;/p&gt;

&lt;p&gt;可以借鉴Compaction那样的思路，将不确定的临时数据写入临时文件，当可以确定时写入正式的结果文件中,规避性能问题。&lt;/p&gt;

&lt;p&gt;最好还是把这些数据存入数据库吧，时序数据库千千万。&lt;/p&gt;
</description>
        <pubDate>Wed, 28 Jul 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-07-28-writefile</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-07-28-writefile</guid>
        
        
        <category>shell</category>
        
        <category>file</category>
        
      </item>
    
      <item>
        <title>flock</title>
        <description>&lt;p&gt;最近购买了一台腾讯云的服务器跑一些小程序，在整理crontab时发现了一个腾讯云的定时任务，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*/5 * * * * flock -xn /tmp/stargate.lock -c '/usr/local/qcloud/stargate/admin/start.sh &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;脚本是为了保证腾讯云agent存活的，这个不是我们关注的重点，重点是flock这个命令。&lt;/p&gt;

&lt;p&gt;虽然经常与服务器打交道，但是flock这个命令还是比较陌生的。&lt;/p&gt;

&lt;h2 id=&quot;flock&quot;&gt;flock&lt;/h2&gt;

&lt;p&gt;以下内容摘抄自cnblogs。&lt;/p&gt;

&lt;p&gt;如果两个进程同时启动了某个脚本，那么很容易导致数据的混乱，这个时候需要锁来协调解决。&lt;/p&gt;

&lt;p&gt;flock是建议性锁，不具备强制性。一个进程使用flock将文件锁住，另一个进程也可以直接操作正在被锁的文件，修改文件中的数据。&lt;/p&gt;

&lt;p&gt;flock只是用于检测文件是否被加锁，针对文件已经被加锁，另一个进程写入数据的情况，内核不会阻止这个进程的写入操作。&lt;/p&gt;

&lt;p&gt;flock主要三种操作类型：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LOCK_SH，共享锁，多个进程可以使用同一把锁，常被用作读共享锁；
LOCK_EX，排他锁，同时只允许一个进程使用，常被用作写锁；
LOCK_UN，释放锁；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section&quot;&gt;参数&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-s,--shared：获取一个共享锁，在定向为某文件的FD上设置共享锁而未释放锁的时间内，其他进程试图在定向为此文件的FD上设置独占锁的请求失败，而其他进程试图在定向为此文件的FD上设置共享锁的请求会成功。
-x，-e，--exclusive：获取一个排它锁，或者称为写入锁，为默认项
-u，--unlock：手动释放锁，一般情况不必须，当FD关闭时，系统会自动解锁，此参数用于脚本命令一部分需要异步执行，一部分可以同步执行的情况。
-n，--nb, --nonblock：非阻塞模式，当获取锁失败时，返回1而不是等待
-w, --wait, --timeout seconds：设置阻塞超时，当超过设置的秒数时，退出阻塞模式，返回1，并继续执行后面的语句
-o, --close：表示当执行command前关闭设置锁的FD，以使command的子进程不保持锁。
-c, --command command：在shell中执行其后的语句
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;最后&lt;/h2&gt;

&lt;p&gt;flock可以让很多脚本程序变得更规范，比如我有一些增量计算数据的脚本，如果不小心并发执行了就会导致数据错乱。&lt;/p&gt;

&lt;p&gt;以前不知道这个命令，都是用一个lock文件来替代，在脚本中判断文件是否存在，非常的繁琐，也不是很严谨。&lt;/p&gt;

&lt;p&gt;你是更喜欢把flock放在脚本外部，还是写在脚本里呢？&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Jun 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-06-13-flock</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-06-13-flock</guid>
        
        
        <category>shell</category>
        
        <category>lock</category>
        
      </item>
    
      <item>
        <title>CMD</title>
        <description>&lt;p&gt;使用linux的命令时，经常会用man来查询可选参数及其含义。偶尔我们也会开发自己的小工具。&lt;/p&gt;

&lt;p&gt;如何给小工具快速添加可选参数呢？&lt;/p&gt;

&lt;h2 id=&quot;java&quot;&gt;java&lt;/h2&gt;

&lt;p&gt;java的开发者应该是更喜欢使用配置文件的方式来与程序交互，无论是property还是yml。&lt;/p&gt;

&lt;p&gt;在参数不是特别多时，cmd的params也是不错的选择。提到给java传参数，大多数人一定是会&lt;/p&gt;

&lt;p&gt;想到main函数的args数组，这是基础，但不太方便。&lt;/p&gt;

&lt;p&gt;推荐使用commons-cli，能够设定长短参数(-i 或 –interval)，还能添加注解。&lt;/p&gt;

&lt;p&gt;具体的方法我就不展开讲了，网上能搜到很多。&lt;/p&gt;

&lt;h2 id=&quot;getopts&quot;&gt;getopt(s)&lt;/h2&gt;

&lt;p&gt;shell中最普遍的解决办法就是getopt，配合while case处理输入的参数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while getopts 'h:j:m:u' OPT;do
    case $OPTin
        j) S_DIR=&quot;$OPTARG&quot;;;
        m) D_DIR=&quot;$OPTARG&quot;;;
        u) upload=&quot;true&quot;;;
        h) func;;
        ?) func;;
    esac
done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如何你想实现tab自动提示的话，可以了解一下_get_comp_words_by_ref。&lt;/p&gt;

&lt;h2 id=&quot;shell&quot;&gt;shell默认的参数处理&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
$0 : 脚本名
$N : 第N个参数.
$# : 参数的个数，不包括命令本身.
$@ : 参数本身的列表，也不包括命令本身，如上例为 -v -f -out /test.log –prefix=/home
$* : 参数本身的列表，也不包括命令本身，但”$*” 和”\$@”(加引号)并不同，”$*“将所有的参数解释成一个字符串，而”$@”是一个参数数组。

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种处理方法没有getopt简洁，一般还是推荐使用getopt。但是下面这个特殊用法需要注意一下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&quot;${@:2}&quot;  从第二参数开始往后的所有参数

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 20 May 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-05-20-CMD</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-05-20-CMD</guid>
        
        
        <category>cmd</category>
        
        <category>shell</category>
        
      </item>
    
      <item>
        <title>UniswapOracle</title>
        <description>&lt;p&gt;这次聊聊Uniswap的预言机，上次我们介绍的Chainlink属于通用预言机。&lt;/p&gt;

&lt;p&gt;在Uniswap项目中，内置了一个预言机功能，算是专用吧，具有一定的特殊性。&lt;/p&gt;

&lt;h2 id=&quot;uniswap&quot;&gt;Uniswap&lt;/h2&gt;

&lt;p&gt;Uniswap最近一年非常的火热，算是Defi的基石项目了。随着其V3版本的发布，&lt;/p&gt;

&lt;p&gt;会吸引越来越多的做市商。这里介绍一个&lt;a href=&quot;https://liaoph.com/&quot;&gt;Blog&lt;/a&gt;。可以作为Uniswap的入门资料。&lt;/p&gt;

&lt;h2 id=&quot;uniswaporacle&quot;&gt;Uniswap的Oracle&lt;/h2&gt;

&lt;p&gt;之前讲的Chainlink的预言机，使用者大多关注当前价格，少量场景也需要历史价格。&lt;/p&gt;

&lt;p&gt;Uniswap的Oracle是提供时间加权平均价，并且可以随意指定周期。设计出这样的Oracle，&lt;/p&gt;

&lt;p&gt;主要是为了抵御价格操纵闪电贷之类的攻击。在目前的Defi项目中，这类需求还是比较普遍的。&lt;/p&gt;

&lt;p&gt;我个人觉得Uniswap的Oracle时间加权思路是不错的，但不适合普及使用。比如标的非常有限、&lt;/p&gt;

&lt;p&gt;存储数据的精度问题等等。但是提供的按照时间二分查找的功能是Chainlink所缺少的。&lt;/p&gt;

&lt;h2 id=&quot;ema&quot;&gt;通用化EMA指标预言机&lt;/h2&gt;

&lt;p&gt;在清算类的业务中，一般使用指数类的价格，比如MA、EMA。期货合约的清算逻辑，&lt;/p&gt;

&lt;p&gt;用来计算是否强制平仓的价格，就不会使用现货的当前价格，一般是EMA(5min)之类的。&lt;/p&gt;

&lt;p&gt;主要是为了削弱价格剧烈波动导致的连锁爆仓反应。&lt;/p&gt;

&lt;p&gt;如果提供一种类似EMA计算的指标价格预言机，我相信会对清算类的业务非常友好。&lt;/p&gt;

&lt;p&gt;可以沿用现有预言机的大部分接口，没有数据精度问题，可轻松获取历史轨迹，作为独立&lt;/p&gt;

&lt;p&gt;计算存储的合约，不与其他项目绑定，可重复利用现有“共识”预言机的结果，保证准确。&lt;/p&gt;

&lt;p&gt;当然这样的方案相对Uniswap的Oracle会缺少一个周期的灵活性，但我个人认为这个不是&lt;/p&gt;

&lt;p&gt;十分重要，大多数项目需要的周期都是可以协调的，而且固定。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;最后&lt;/h2&gt;

&lt;p&gt;预言机的话题就告一段落，这个领域也算是刚刚起步，Chainlink也在快速发展中，希望能够&lt;/p&gt;

&lt;p&gt;有更开放的社区，可以有更多的协作模式，让开发者参与共建。&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Apr 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-04-27-UniswapOracle</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-04-27-UniswapOracle</guid>
        
        
        <category>Uniswap</category>
        
        <category>Oracle</category>
        
      </item>
    
      <item>
        <title>Chainlink</title>
        <description>&lt;p&gt;Chainlink目前已经是预言机领域里的顶流项目，无论是经济模型还是架构设计&lt;/p&gt;

&lt;p&gt;都非常值得学习的。&lt;/p&gt;

&lt;h2 id=&quot;oracle&quot;&gt;预言机Oracle&lt;/h2&gt;

&lt;p&gt;因为以太坊区块链上无法发起对外部世界的请求，也就是无法直接获取外部数据，&lt;/p&gt;

&lt;p&gt;极大的限制了智能合约的使用范围。将外部数据引入区块链世界，就是预言机的职能，&lt;/p&gt;

&lt;p&gt;将拉取数据变为推送数据，保存在合约里。这一点与流计算中的恰好一次，其实是&lt;/p&gt;

&lt;p&gt;非常相似的问题。如果你想让流计算可以反复执行，且结果是恰好一次的，那需要&lt;/p&gt;

&lt;p&gt;严格控制堆外的依赖，比如Redis的计数器、外部系统的实时数据接口等。&lt;/p&gt;

&lt;p&gt;解决外部依赖问题时，经常是将外部数据写入流中（或join）、在流引擎内保存状态。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;成本问题&lt;/h2&gt;

&lt;p&gt;改为推送数据模式后，面临极大的成本问题。如果数据频繁发生变化，那就需要不断调用&lt;/p&gt;

&lt;p&gt;合约的更新方法。但链上业务使用数据并不一定那么频繁。或者是某些数据使用不太频繁。&lt;/p&gt;

&lt;p&gt;这个成本问题就极大的制约了预言机服务的范围，目前看几个主流预言机项目提供的数据&lt;/p&gt;

&lt;p&gt;总共也不超过100种。而且更新频率都不是很高，一般10分钟左右。&lt;/p&gt;

&lt;p&gt;除了写入成本以外，还有共识成本。比如早期的Chainlink所有节点都会把数据上报到合约中，&lt;/p&gt;

&lt;p&gt;最后算一个中位数。每一轮都会有20个左右的节点参与。相当于把写入成本放大了20倍。&lt;/p&gt;

&lt;p&gt;当然现在的Chainlink OCR已经把这个问题解决了，思路就是把共识环节放在低成本链去实现。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;共识问题&lt;/h2&gt;

&lt;p&gt;预言机的数据真的可以依靠共识来解决么？这是个非常值得讨论的话题，虽然共识是区块链&lt;/p&gt;

&lt;p&gt;类型的项目惯用的手法。但很多都是生搬硬套来的，并不是很恰当。API3项目的思路也不错，&lt;/p&gt;

&lt;p&gt;预言机的数据由可信的权威机构来提供，绕过了关于数据正确的证明过程，只解决可用性问题。&lt;/p&gt;

&lt;p&gt;Chainlink是依靠质押处罚、门限签名等手段来防止数据错误，再最新的计划里还将引入一些&lt;/p&gt;

&lt;p&gt;博弈论的思路，比如囚徒困境等，增加被攻击的难度。显然这些手段都是有一定积极效果的，&lt;/p&gt;

&lt;p&gt;但是为此付出的成本也是极大的，我个人并不看好这种发展思路。Chainlink未来的计划还是&lt;/p&gt;

&lt;p&gt;很值得期待的，主要是在零知识证明方向上，可信计算和验证等技术。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;服务模式&lt;/h2&gt;

&lt;p&gt;Chainlink采用的技术以去中心化为主，但是运用模式还是一个典型的中心化模式。&lt;/p&gt;

&lt;p&gt;毕竟当前还是处于发展的早期阶段，希望未来的Chainlink可以越来越自由化。&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Mar 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-03-16-chainlink</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-03-16-chainlink</guid>
        
        
        <category>chainlink</category>
        
      </item>
    
      <item>
        <title>ETH合约</title>
        <description>&lt;p&gt;最近开始接触了一下ETH的智能合约，主要是通过Chainlink这个优秀的预言机项目。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;合约的特点&lt;/h2&gt;

&lt;p&gt;ETH上的合约主要是用Solidity语言来开发的，使用下来感觉语言本身还不是很成熟，&lt;/p&gt;

&lt;p&gt;数据结构比较单一，适合实现简单的计算逻辑和数据存储。&lt;/p&gt;

&lt;p&gt;与其他开发项目相比，代码一旦发布后很难修改，代码“性能”需要特别关注。&lt;/p&gt;

&lt;p&gt;合约代码在执行过程中依据Op来计算需要消耗的gas费，所以代码的质量非常关键。&lt;/p&gt;

&lt;p&gt;在我们了解Chainlink项目和开发自己的合约时碰到了下面几个案例，分享一下。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;写入与更新&lt;/h3&gt;

&lt;p&gt;Chainlink的历史数据是保存在合约的一个Map中，key是roundid，value是价格。&lt;/p&gt;

&lt;p&gt;在我们测试Map的写入与更新时发现，第一次写入某一个key和后面更新key的Value，&lt;/p&gt;

&lt;p&gt;费用差距是巨大的，大概是2倍左右。我们在设计类似保存历史数据的环节时，采用了&lt;/p&gt;

&lt;p&gt;循环key值，比如自增ID对1024取模，这样只有第一轮是insert，第1025次之后就是&lt;/p&gt;

&lt;p&gt;update了，费用会降低下来，在合约里只能查询一段时间的历史记录，之前的会被覆盖。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;代理&lt;/h3&gt;

&lt;p&gt;因为链上的合约一旦部署成功后，就不能修改了，如果想要升级就要使用新的合约地址了，&lt;/p&gt;

&lt;p&gt;这对外部依赖是非常不友好的。参考Chainlink和Openzapplin项目，一般都是采用代理&lt;/p&gt;

&lt;p&gt;模式将接口和实现解耦和，接口层记录了实现合约的地址，提供一个Update实现合约地址的&lt;/p&gt;

&lt;p&gt;方法，进行替换，来达到升级的目的。虽然可以实现，但是开发时非常繁琐。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;存储与计算分离&lt;/h3&gt;

&lt;p&gt;上面提到了升级的问题，如果你的合约里还保存了一些数据，那么在升级时也需要将其转移到&lt;/p&gt;

&lt;p&gt;新的合约里。部署合约是有费用成本的，如果在部署合约时，涉及到了大量的数据copy，&lt;/p&gt;

&lt;p&gt;这个成本会变得非常昂贵。代理模式只是解决了升级当中的持续稳定服务问题，在设计合约时，&lt;/p&gt;

&lt;p&gt;还需要将合约里的存储结构和计算逻辑进行解耦，一般我们只对计算逻辑进行升级，而存储部分&lt;/p&gt;

&lt;p&gt;不会移动，仅仅会修改一些写权限的控制，将新合约地址更新到存储数据的合约中去。&lt;/p&gt;
</description>
        <pubDate>Mon, 22 Feb 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-02-22-contract</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-02-22-contract</guid>
        
        
        <category>contract</category>
        
      </item>
    
      <item>
        <title>Master选举</title>
        <description>&lt;p&gt;今年的第一篇就写写Master的选举吧，在之前的工作经历中，我们经常碰到Master选举问题。&lt;/p&gt;

&lt;p&gt;比如Hbase、Hadoop的Master选举，都是通过Zookeeper来完成的，这几年比较流行K8s，&lt;/p&gt;

&lt;p&gt;很多组件的选举是通过ETCD来完成的。说到这需要补充一点背景知识，那就是Paxos和Raft，&lt;/p&gt;

&lt;p&gt;这里就不详细陈述了，自行搜索。&lt;/p&gt;

&lt;h2 id=&quot;redis&quot;&gt;通过Redis选举&lt;/h2&gt;

&lt;p&gt;不是任何时候我们都能使用ZK、ETCD来完成选举的，比如部署规模的限制。最近碰到了一个场景，&lt;/p&gt;

&lt;p&gt;需要进行Master的选举，但是部署规模非常小，无法引入其他组件来辅助，项目中有使用到Redis，&lt;/p&gt;

&lt;p&gt;于是开发了一个基于Redis的简易选举方案。&lt;/p&gt;

&lt;h3 id=&quot;redis-1&quot;&gt;如何利用Redis选举&lt;/h3&gt;

&lt;p&gt;网上有很多文章介绍，大体都是基于Redis的SetN指令的特性，进行一个分布式锁的争抢过程，&lt;/p&gt;

&lt;p&gt;抢到锁的即为Master。如果你使用过Redission的客户端，可以直接使用Rlock来完成这个工作。&lt;/p&gt;

&lt;p&gt;Redission中大量的封装了LuaScript，来完成一些事务性的工作。&lt;/p&gt;

&lt;h3 id=&quot;redis-2&quot;&gt;利用Redis选举的弊端&lt;/h3&gt;

&lt;p&gt;为了性能考量，在写入时只要主节点成功，就会返回True。所以在故障时，主从可能会不一致。&lt;/p&gt;

&lt;p&gt;在抢锁这个场景中，也就是会短暂出现两把锁。当然通过结构上的设计是可以尽量降低这个概率的，&lt;/p&gt;

&lt;p&gt;但无法彻底消除。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;选举的大致逻辑&lt;/h3&gt;

&lt;p&gt;1、 无锁时，争抢创建锁&lt;/p&gt;

&lt;p&gt;2、 有锁时，没有抢到锁的节点，观察等待锁消失&lt;/p&gt;

&lt;p&gt;3、 有锁时，抢到锁的节点，延续锁的TTL&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;代码示例&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while (true) {
            try {
                RBucket&amp;lt;String&amp;gt; currentLock = this.redis.getBucket(this.lockName, StringCodec.INSTANCE);
                String currentLockValue = currentLock.get();

                if (StringUtils.isBlank(currentLockValue)) {
                    if (log.isDebugEnabled()) {
                        log.debug(&quot;start election .&quot;);
                    }
                    boolean success = currentLock.trySet(this.deviceId, DURATION_TIME, TimeUnit.SECONDS);
                    if (log.isDebugEnabled()) {
                        log.debug(&quot;election result : &quot; + success);
                    }
                    update(success);
                    Util.sleepSec(10);
                } else {
                    long remainTime = currentLock.remainTimeToLive();
                    if (remainTime &amp;lt;= 0) {
                        continue;
                    }
                    String tValue = currentLock.get();
                    if (!currentLockValue.equals(tValue)) {
                        continue;
                    }

                    if (this.deviceId.equals(currentLockValue)) {
                        if (log.isDebugEnabled()) {
                            log.debug(&quot;I am master .&quot;);
                        }
                        if (remainTime &amp;gt;= TimeUnit.SECONDS.toMillis(DISPUTE_TIME)) {
                            currentLock.expire(DURATION_TIME, TimeUnit.SECONDS);
                            if (log.isDebugEnabled()) {
                                log.debug(&quot;renew lock ttl .&quot;);
                            }
                            update(true);
                        } else {
                            update(false);
                            if (log.isDebugEnabled()) {
                                log.debug(&quot;unstable .&quot;);
                            }
                        }
                        Util.sleepSec(10);
                    } else {
                        update(false);
                        if (log.isDebugEnabled()) {
                            log.debug(&quot;wait for next time .&quot;);
                        }
                        Util.sleepMS(remainTime);
                    }
                }
            } catch (Throwable e) {
                log.error(&quot;Election Error : &quot;, e);
                Util.sleepSec(1);
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 19 Jan 2021 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2021-01-19-master</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2021-01-19-master</guid>
        
        
        <category>master</category>
        
      </item>
    
      <item>
        <title>2020年总结</title>
        <description>&lt;p&gt;2020年真的非常魔幻，也经历了很多变化。庆幸的是现在做的事情是自己喜欢的。&lt;/p&gt;

&lt;p&gt;以前都是写写总结，这次就写设想和展望吧。&lt;/p&gt;

&lt;p&gt;希望2021年能更新一下自己的Java知识，这几年一直在使用Java8，也是时候升级了。&lt;/p&gt;

&lt;p&gt;需要补充一点Go或者Rust的知识，看一些区块链项目的时候会用到。如果还有时间的话，&lt;/p&gt;

&lt;p&gt;Lua还需要捡起来了，未来也会用得上。&lt;/p&gt;

&lt;p&gt;2021年需要花点时间在机器学习的入门上，这方面之前没什么涉猎，可能会辛苦一点。&lt;/p&gt;

&lt;p&gt;之前几年的工作都和算法没什么关系，这方面需要多储备一点了。&lt;/p&gt;

&lt;p&gt;2021年需要多学习一些金融知识，尤其是期权和对冲相关的。&lt;/p&gt;

&lt;p&gt;之前几年都在做实时流计算方面的事，尤其是今年实时流计算非常的火热，但我并不看好这个方向。&lt;/p&gt;

&lt;p&gt;实时计算是个非常昂贵的事情，并不能普及在大多数无价值和意义的业务和数据上，完全是在浪费。&lt;/p&gt;

&lt;p&gt;真正有实时价值的业务其实非常的少，目前在跑的实时业务有很多是在滥竽充数，完成KPI而已。&lt;/p&gt;

&lt;p&gt;那些真正具有“实时”要求的业务，Flink也是无法满足的，因为他的实时能力是非常有限的。&lt;/p&gt;

&lt;p&gt;2021年我不会投入精力在这方面了，很有可能会转向CEP，也算是个延续吧。&lt;/p&gt;

&lt;p&gt;工作十年，大多实在研究技术本身，而非业务问题。从2021年开始，我会更关注问题本身，&lt;/p&gt;

&lt;p&gt;从另外一个角度来组合使用这些年的积累和认知。&lt;/p&gt;

&lt;p&gt;感谢各位看官，来年再见。&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Dec 2020 10:00:00 +0800</pubDate>
        <link>http://peiliping.github.io/blog/archivers/2020-12-30-summary</link>
        <guid isPermaLink="true">http://peiliping.github.io/blog/archivers/2020-12-30-summary</guid>
        
        
        <category>summary</category>
        
      </item>
    
  </channel>
</rss>
