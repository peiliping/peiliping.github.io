<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Redis中的Bitmap数据结构 « Pei LiPing's Blog</title>
  <meta name="description" content="Redis最早被大家熟知，是因为其高效的读写速率和丰富的数据结构。">

  <link rel="stylesheet" href="/blog/css/main.css">
  <link rel="canonical" href="http://peiliping.github.io/blog/archivers/2017-09-12-redis-bit">
  <link rel="alternate" type="application/rss+xml" title="Pei LiPing's Blog" href="http://peiliping.github.io/blog/feed.xml" />
</head>


  <body>

    <header class="header">
  <div class="wrapper">
    <a class="site-title" href="/blog/">Pei LiPing's Blog</a>
    <nav class="site-nav">
      
        
      
        
        <a class="page-link" href="/blog/about/">About</a>
        
      
        
        <a class="page-link" href="/blog/category/">Category</a>
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    </nav>
  </div>
</header>

    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Redis中的Bitmap数据结构</h1>
    <p class="post-meta">Sep 1, 2017</p>
  </header>

  <article class="post-content">
    <p>Redis最早被大家熟知，是因为其高效的读写速率和丰富的数据结构。</p>

<p>近两年在实时计算方面的应用也非常多，尤其是与bit有关的操作。</p>

<h2 id="redisbit">Redis中常见的Bit操作</h2>

<p>1、SetBit
2、GetBit
3、BitOp
4、BitPos
5、BitField</p>

<h2 id="section">计算日活跃用户</h2>

<p>计算日活是一个非常古老的话题，也是面试题目中很常见的一个问题。</p>

<p>其变种问题有：有限内存的数据排序，在线用户统计等等。</p>

<p>在网上有很多文章介绍如何利用Redis做高效的日活统计，请自行阅读。</p>

<p>使用bitmap来作为数据的存储好处就是高效、节省内存。</p>

<h2 id="section-1">维度分析的需求</h2>

<p>单一的日活跃统计已经不能满足需求了，在实际工作中，运营人员希望能够实现</p>

<p>一些更为复杂的统计分析，比如漏斗模型、多维度组合分析等等。有很多公司</p>

<p>已经积累了大量的用户特征数据，开始完善用户画像，通过用户的特征来优化</p>

<p>业务，提高商业价值。简单概括，我们需要一个列式的存储，方便增加新列，</p>

<p>需要类似bitmap的索引能够高效完成多个维度的快速筛选。</p>

<p>近几年以BitMap索引著称的Druid，是一个非常好的选择，在维度统计方面</p>

<p>性能优异，缺点就是架构比较复杂，维护成本比较高。另外还有ES、Kylin等。</p>

<p>也有人用Hyperloglog之类的数据结构做日活统计，但不能解决多维度的问题。</p>

<h2 id="redis--lua">Redis + Lua</h2>

<p>Redis提供了Bit，但不足以完成多维分析的操作，于是引入LuaScript。</p>

<p>使用过Redis的人都知道通过批量提交可以提升效率，如果我们的需求是先Get</p>

<p>在Put，那么这个原子性就很难保证。LuaScript可以把这种业务逻辑封装好，</p>

<p>在Redis服务器上执行，因为Redis本身的单线程特性，不用再处理并发问题了。</p>

<p>如果我们的计算逻辑包含迭代，那么让Lua在Redis内部完成效率会更高。</p>

<h2 id="bitmmap">如何构建BitmMap索引</h2>

<p>每个维度的每一个值都要单独构建一个BitMap，所以需要维护一个Value的列表。</p>

<p>之前在看Kylin的时候，有用一个TrieTree的结构维护Value字典信息。</p>

<p>Sybase之前有一个专利叫BitWise，结合TrieTree，可以方便实现Between逻辑。</p>

<p>维度值的膨胀是一个需要高度关注的问题，如果控制不好会吃掉非常多的存储空间。</p>

<p>假如我们有一亿个用户ID，Bitmap就非常大，因为数据不连续，非常浪费内存。</p>

<p>所以我们要对数据做一下分块的操作，比如每16384个连续用户ID为一个Block。</p>

<p>Block的大小会影响存储的开销，如果分的太小，会导致查询性能下降。</p>

<p>因为数据分了Block，所以还需要维护一个Block的列表。这个地方和之前在</p>

<p>扩展Roaringbitmap的时候是一样，通过位移运算来计算offset。</p>

<p>如果没有什么附加信息的话，我们仍然可以用Bitmap来维护这个列表。</p>

<h2 id="section-2">如何查询</h2>

<p>BitMap的操作类型就是逻辑运算(与、或、非)，那么根据选取的维度列序号和</p>

<p>维度值找到Bitmap，再对BitMap进行逻辑运算，结果保存在一个临时的Key中，</p>

<p>最后对其求bitcount，释放内存。</p>

<p>遍历Block列表的时候，我用到了BitPos，这个操作的参数非常麻烦，</p>

<p>参数是byte级别的，返回值是bit，需要自己加逻辑去控制一下。</p>

<h2 id="demo-code">demo code</h2>

<p>在Redis里执行的脚本，负责写入数据和查询数据</p>

<div class="highlighter-rouge"><pre class="highlight"><code>local resty_redis = require "resty.redis"
local redis       = resty_redis:new()
redis:set_timeout(1000)
local ok , err    = redis:connect("127.0.0.1", 6379)

if err then
  ngx.say(err)
  return
end

local scripts = ngx.shared.scripts

local shaw = redis:script("LOAD" , 
[[
  local tableName , dateTime , uidNumber = KEYS[1] , KEYS[2] , tonumber(KEYS[3])
  
  local blockSeq , lineSeq 
  if uidNumber &gt;= 2147483648 then
  	blockSeq = math.modf(uidNumber / 16384)  
  	lineSeq  = uidNumber % 16384
  else
  	blockSeq , lineSeq = bit.rshift(uidNumber , 14) , bit.band(uidNumber , 16383)
  end
  
  local keyT4N = {"T-" , tableName , "-" , dateTime , "-Nest"}
  local keyT4V = {"T-" , tableName , "-" , dateTime , "-" , 6 , "-" , "VS"}
  local keyT4M = {"T-" , tableName , "-" , dateTime , "-" , 6 , "-" , 8 , "-BMP-" , blockSeq}

  for index , val in ipairs(ARGV) do
    keyT4V[6] , keyT4M[6] = index , index
    local key4V = table.concat(keyT4V)
    local m = redis.call("SISMEMBER" , key4V , val)
    if m == 1 then
      keyT4M[8] = val
      local key4M = table.concat(keyT4M)
      redis.call("setbit" , key4M , lineSeq , 1)  
    else
      local totalNum = redis.call("SCARD" , key4V)
      
      if totalNum &gt;= 1024 then
        val = "IGNORE"
      end
      if totalNum &lt;= 1024 then 
        redis.call("SADD" , key4V , val)
      end
      
      if totalNum == 0 then
        redis.call("expire" , key4V , 86400 * 7)    
      end

      keyT4M[8] = val
      local key4M = table.concat(keyT4M)
      redis.call("setbit" , key4M , lineSeq , 1)
      redis.call("expire" , key4M , 86400 * 7)
    end
  end
  local key4N = table.concat(keyT4N)
  redis.call("setbit" , key4N , blockSeq , 1)
  return true
]]
)

scripts:set("WriteScript", shaw)
ngx.say("WriteScript : " .. shaw)

local shar = redis:script("LOAD" , 
[[
  local result = 0
  local tableName , dateTime = KEYS[1] , KEYS[2]
  
  local keyT4N = {"T-" , tableName , "-" , dateTime , "-Nest"}
  local key4N = table.concat(keyT4N)

  local subKeys , subKeysT = {} , {}
  for index = 1 , #ARGV , 2 do
    table.insert(subKeysT , {"T-" , tableName , "-" , dateTime , "-" , ARGV[index] , "-" , ARGV[index+1] , "-BMP-" , 10})
  end

  local bytepos = 0
  local pos = redis.call("bitpos" , key4N , 1 , bytepos)
  while (pos &gt;= 0)
  do
    for g = pos , pos + 7 - bit.band(pos , 7) do
      local fill = redis.call("getbit" , key4N , g)
      if fill == 1 then
        for index , val in ipairs(subKeysT) do
          val[10] = g
          subKeys[index] = table.concat(val)
        end
        redis.call("bitop" , "AND" , "_TMP_" , unpack(subKeys))
        local uv = redis.call("bitcount" , "_TMP_")
        result = result + uv
      end
    end

    bytepos = bit.rshift(pos , 3) + 1 
    pos = redis.call("bitpos" , key4N , 1 , bytepos)
  end
  redis.call("del" , "_TMP_")
  return result
]]
)

scripts:set("ReadScript", shar)
ngx.say("ReadScript : " .. shar)

redis:close()

</code></pre>
</div>

<p>Openresty+lua包装的查询接口</p>

<div class="highlighter-rouge"><pre class="highlight"><code>local ngx_re      = require "ngx.re"
local resty_redis = require "resty.redis"
local redis       = resty_redis:new()
redis:set_timeout(1000)
local ok , err    = redis:connect("127.0.0.1", 6379)

if err then
  ngx.say(err)
  return
end

local scripts = ngx.shared.scripts

local tableName = ngx.var.arg_table
local dateTime  = ngx.var.arg_datetime

local dimsStr   = ngx.var.arg_dims
local dims      = ngx_re.split(dimsStr , ",")

local r = redis:evalsha(scripts:get("ReadScript") , 2 , tableName , dateTime , unpack(dims))
ngx.say(r)
redis:close()
</code></pre>
</div>

  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="//www.gravatar.com/avatar/your_email_md5?d=mm&s=135" alt="Pei LiPing">
  <div class="col-box-title name">Pei LiPing</div>
  <p>The Cabin Of Pei LiPing.</p>
  <p class="contact">
    
    
    
    <a href="mailto:peilipingplp@gmail.com">Email</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">Newest Posts</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/blog/archivers/2017-09-12-redis-bit">Redis中的Bitmap数据结构</a></li>
    
      <li><a class="post-link" href="/blog/archivers/2017-09-01-lpeg">Lpeg与模式匹配</a></li>
    
      <li><a class="post-link" href="/blog/archivers/2017-08-09-performance">关于性能优化</a></li>
    
      <li><a class="post-link" href="/blog/archivers/2017-08-01-64bitmap">支持long型的bitmap</a></li>
    
      <li><a class="post-link" href="/blog/archivers/2017-07-05-flume">Flume优化</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">TOC</div>
</div>
        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2016 Pei LiPing
</div>
</footer>

<script src="//upcdn.b0.upaiyun.com/libs/jquery/jquery-1.9.0.min.js"></script>
<script src="/blog/js/easybook.js"></script>

  </body>

</html>
