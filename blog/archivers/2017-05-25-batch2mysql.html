<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>批量写入Mysql « Pei LiPing's Blog</title>
  <meta name="description" content="Mysql是最常用的一种关系型数据库，随着各种ORM框架的演进，操作数据库也越来越简单。">

  <link rel="stylesheet" href="/blog/css/main.css">
  <link rel="canonical" href="http://peiliping.github.io/blog/archivers/2017-05-25-batch2mysql">
  <link rel="alternate" type="application/rss+xml" title="Pei LiPing's Blog" href="http://peiliping.github.io/blog/feed.xml" />
</head>


  <body>

    <header class="header">
  <div class="wrapper">
    <a class="site-title" href="/blog/">Pei LiPing's Blog</a>
    <nav class="site-nav">
      
        
      
        
        <a class="page-link" href="/blog/about/">About</a>
        
      
        
        <a class="page-link" href="/blog/category/">Category</a>
        
      
        
      
        
      
        
      
    </nav>
  </div>
</header>

    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">批量写入Mysql</h1>
    <p class="post-meta">May 25, 2017</p>
  </header>

  <article class="post-content">
    <p>Mysql是最常用的一种关系型数据库，随着各种ORM框架的演进，操作数据库也越来越简单。</p>

<p>当你碰到一些极端需求时，还是要在JDBC这个层面上来操作数据库。</p>

<p>今里就介绍一下，在批量写Mysql时碰到的问题。</p>

<h3 id="section">真正的批量写</h3>

<p>使用JDBC来完成批量Mysql写入的一般方法是:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>this.connection.setAutoCommit(false);

this.preparedStatement = this.connection.prepareStatement(this.sql);
for (int i = 0; i &lt; this.schema.size(); i++) {
    this.preparedStatement.setObject(i + 1, data[i], this.schema.get(i));
}
this.preparedStatement.addBatch();

...N次

this.preparedStatement.executeBatch();
this.connection.commit();
</code></pre>
</div>

<p>当你写完这段代码之后，测试性能会发现，并没有什么提升。因为实际上还是一条条发送执行的。</p>

<p>当你为DatasourceUrl添加了参数rewriteBatchedStatements=true，才会真正生效。</p>

<p>具体原因可以自行搜索这个参数，网上有很多文章介绍。</p>

<p>改了参数，性能提升三五倍是很轻松的，具体能提升多少要看实际的情况。</p>

<h3 id="section-1">选择好数据库的伴侣——数据源连接池</h3>

<p>开源的数据源连接池非常多，c3p0、druid、Proxool、BoneCP、HikariCP等等。</p>

<p>比较常用的是阿里开源的Druid，性能不是特别突出，但是综合表现不错。</p>

<p>HikariCP也是性能表现很抢眼的选手。</p>

<h3 id="section-2">缓冲区</h3>

<p>涉及到批量写入数据库就意味着可能和缓冲区打交道了。</p>

<p>攒够一个批量（100条），但是也不能无限期的等，需要一个超时时间（15秒）。</p>

<p>缓冲区可以用框架来实现，比如Disruptor的Ringbuffer无锁队列就可以满足这两个要求。</p>

<p>Ringbuffer的具体使用方法这里就不介绍了，初次上手会有一些难度。</p>

<p>Ringbuffer强制了数据对象的复用，来减少JVM GC的次数，对性能的提升非常有帮助。</p>

<h3 id="section-3">线程数和批量大小</h3>

<p>加大处理数据的线程数也是一个提升处理速度的方法，当然也不能一直加大线程数，</p>

<p>根据测试批量写的线程数不要超过Mysql的Cpu核数+1。</p>

<p>批量条数要根据单行数据的大小决定，一般1000条左右。</p>

<h3 id="mysql">Mysql性能优化</h3>

<p>Mysql的性能优化去参考网上的文章，这里就不详细介绍了。</p>

<p>大多是关闭一些log，提高一些buffer，改变filesync的方式等。</p>

<p>表上的索引是很影响写入性能的，尽量保证索引精简。</p>

<h3 id="jdbc">JDBC优化</h3>

<p>根据前面的优化过后，使用JFR对你的程序做一下热点代码分析，就会发现JDBC的问题了。</p>

<p>如果你仔细阅读过Java的MysqlConnector的代码就会发现，可以改造的地方还是挺多的。</p>

<p>下面举几个例子：</p>

<p>1、批量数据的暂存容器</p>

<p>你提交到preparestatment中的数据，会暂时存到一个ArrayList中。</p>

<p>在大批量数据处理时Arraylist就是一个优化点。跟HashMap一样，它也会涉及到resize的过程。</p>

<p>在你初始化一个preparestatment的时候，根据你的批量大小，对其进行capacity的初始化，会带来不小的性能提升。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>this.batchArgsField = StatementImpl.class.getDeclaredField("batchedArgs");
this.batchArgsField.setAccessible(true);
...
this.batchArgsField.set((StatementImpl) ((DruidPooledPreparedStatement) this.preparedStatement).getStatement(), new ArrayList&lt;Object&gt;(stepSize));

</code></pre>
</div>

<p>2、日期格式化</p>

<p>一般数据库表都会有一些日期类型的字段，比如创建时间、更新时间等。</p>

<p>Java中的日期类型处理性能一直都不是很高，比如SimpleDateFormat就是一个关键点。</p>

<p>代码详见com.mysql.jdbc.PreparedStatement.class.getDeclaredField(“tsdf”)，这里就不细说了。</p>

<p>如果你的表字段日期类型比较多，可以考虑替换掉SimpleDateFormat的实现。</p>

<p>比如用Calender的接口，通过字符串拼接的方式完成日期数据的格式化。性能也是会有一定的提升的。</p>

<p>3、失败重试</p>

<p>一个完善的数据处理流程，必然要考虑很多异常场景。比如网络闪断，数据库重启等等。</p>

<p>如果在请求失败后重试呢？一般性的做法就是记录下批量写入的每一个参数，重新写入再执行一边。</p>

<p>前面基于ringbuffer做了数据对象的复用，目的是减少gc，这里为了失败重试，再次引入重复对象是很难接受的。</p>

<p>而且statement.setObject过程就是一个java对象序列化成byte的过程，重复执行也很浪费。</p>

<p>最简单的办法就是利用前面初始化好的batchArgs，实际上他里面就记录了你写入的每一行数据。</p>

<p>只要把它拷贝出来，写入新的preparestatement中，就可以再次执行了。</p>

<p>注意executeBatch()一定不能丢掉</p>

<div class="highlighter-rouge"><pre class="highlight"><code>List&lt;Object&gt; batchParams = ((JDBC4PreparedStatement) ((DruidPooledPreparedStatement) this.preparedStatement).getStatement()).getBatchedArgs();
Connection tc = this.dataSource.getConnection();
tc.setAutoCommit(false);
PreparedStatement tp = tc.prepareStatement(this.sql);
StatementImpl target = (StatementImpl) ((DruidPooledPreparedStatement) tp).getStatement();
List&lt;Object&gt; newParams = new ArrayList&lt;&gt;(batchParams);
this.batchArgsField.set(target, newParams);
tp.executeBatch();
tc.commit();
tp.close();
tc.close();
</code></pre>
</div>

<p>经过这些优化，我的程序（8G的JVM）可以每秒向Mysql写入十几万行数据（无索引的情况）。</p>


  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="//www.gravatar.com/avatar/your_email_md5?d=mm&s=135" alt="Pei LiPing">
  <div class="col-box-title name">Pei LiPing</div>
  <p>The Cabin Of Pei LiPing.</p>
  <p class="contact">
    
    
    
    <a href="mailto:peilipingplp@gmail.com">Email</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">Newest Posts</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/blog/archivers/2017-05-25-batch2mysql">批量写入Mysql</a></li>
    
      <li><a class="post-link" href="/blog/archivers/2017-04-18-meepo">Meepo</a></li>
    
      <li><a class="post-link" href="/blog/archivers/2017-03-31-jfr">Java Flight Recorder</a></li>
    
      <li><a class="post-link" href="/blog/archivers/2016-12-16-nginx">Nginx配置</a></li>
    
      <li><a class="post-link" href="/blog/archivers/2016-12-15-logwatch">日志采集工具Logwatch</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">TOC</div>
</div>
        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2016 Pei LiPing
</div>
</footer>

<script src="//upcdn.b0.upaiyun.com/libs/jquery/jquery-1.9.0.min.js"></script>
<script src="/blog/js/easybook.js"></script>

  </body>

</html>
